From bd7edfd1035ccbd03c6b44fb36ad31f4d3fd02ed Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 19 May 2021 13:33:36 -0400
Subject: [PATCH] winevulkan: Implement VK_KHR_external_memory_win32 for
 buffers.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/vulkan-1/tests/vulkan.c     |   5 +-
 dlls/winevulkan/make_vulkan      |  27 ++-
 dlls/winevulkan/vulkan.c         | 390 +++++++++++++++++++++++++++++--
 dlls/winevulkan/vulkan_private.h |  24 ++
 4 files changed, 424 insertions(+), 22 deletions(-)

diff --git a/dlls/vulkan-1/tests/vulkan.c b/dlls/vulkan-1/tests/vulkan.c
index 75e48bfc9d1..2e2bc58c761 100644
--- a/dlls/vulkan-1/tests/vulkan.c
+++ b/dlls/vulkan-1/tests/vulkan.c
@@ -615,8 +615,9 @@ static void import_memory(VkDevice vk_device, VkMemoryAllocateInfo alloc_info, V
         import_handle_info.name = L"wine_test_buffer_export_name";
 
         vr = vkAllocateMemory(vk_device, &alloc_info, NULL, &memory);
-        ok(vr == VK_SUCCESS, "vkAllocateMemory failed, VkResult %d.\n", vr);
-        vkFreeMemory(vk_device, memory, NULL);
+        todo_wine ok(vr == VK_SUCCESS, "vkAllocateMemory failed, VkResult %d.\n", vr);
+        if (vr == VK_SUCCESS)
+            vkFreeMemory(vk_device, memory, NULL);
     }
 }
 
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 25a9d6ce223..fc5f1e621b4 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -110,7 +110,6 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_EXT_physical_device_drm",
     "VK_GOOGLE_surfaceless_query",
     "VK_KHR_external_fence_fd",
-    "VK_KHR_external_memory_fd",
     "VK_KHR_external_semaphore_fd",
 
     # Extensions which require callback handling
@@ -129,7 +128,7 @@ UNSUPPORTED_EXTENSIONS = [
 # winevulkan may nonetheless use, or extensions we want to generate headers for
 # but not expose to applications (useful for test commits)
 UNEXPOSED_EXTENSIONS = {
-    "VK_KHR_external_memory_win32",
+    "VK_KHR_external_memory_fd",
 }
 
 # The Vulkan loader provides entry-points for core functionality and important
@@ -205,7 +204,7 @@ FUNCTION_OVERRIDES = {
     "vkEnumerateDeviceLayerProperties": {"dispatch": True, "driver": False, "thunk": ThunkType.NONE},
     "vkEnumeratePhysicalDeviceGroups" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkEnumeratePhysicalDevices" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
-    "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceImageFormatProperties2" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
@@ -215,12 +214,15 @@ FUNCTION_OVERRIDES = {
 
     # Device functions
     "vkAllocateCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkAllocateMemory" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkCreateBuffer" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkCreateCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkCreateComputePipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkCreateGraphicsPipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkDestroyCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkFreeCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkFreeMemory" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetDeviceProcAddr" : {"dispatch" : False, "driver" : True, "thunk" : ThunkType.NONE, "loader_thunk" : ThunkType.NONE},
     "vkGetDeviceQueue" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetDeviceQueue2" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
@@ -252,7 +254,7 @@ FUNCTION_OVERRIDES = {
     "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
 
     # VK_KHR_external_memory_capabilities
-    "vkGetPhysicalDeviceExternalBufferPropertiesKHR" : {"dispatch" : False, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetPhysicalDeviceExternalBufferPropertiesKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkGetPhysicalDeviceImageFormatProperties2KHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.PRIVATE},
 
     # VK_KHR_external_semaphore_capabilities
@@ -282,12 +284,20 @@ FUNCTION_OVERRIDES = {
 
     # VK_NV_ray_tracing
     "vkCreateRayTracingPipelinesNV" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
+
+    # VK_KHR_external_memory_win32
+    "vkGetMemoryWin32HandleKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
+    "vkGetMemoryWin32HandlePropertiesKHR" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
 }
 
 STRUCT_CHAIN_CONVERSIONS = {
     # Ignore to not confuse host loader.
     "VkDeviceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"],
     "VkInstanceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"],
+
+    # Structs which require pNext chain modification
+    "VkBufferCreateInfo": [],
+    "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
 }
 
 
@@ -1113,6 +1123,8 @@ class VkHandle(object):
             return "wine_debug_report_callback_from_handle({0})->debug_callback".format(name)
         if self.name == "VkSurfaceKHR":
             return "wine_surface_from_handle({0})->surface".format(name)
+        if self.name == "VkDeviceMemory":
+            return "wine_dev_mem_from_handle({0})->dev_mem".format(name)
 
         native_handle_name = None
 
@@ -1272,7 +1284,8 @@ class VkMember(object):
                     LOGGER.err("OUTPUT parameter {0}.{1} cannot be unwrapped".format(self.type, self.name))
                 else:
                     handle = self.type_info["data"]
-                    return "{0}{1} = {2};\n".format(output, self.name, handle.driver_handle("{0}{1}".format(input, self.name)))
+                    input_name = "{0}{1}".format(input, self.name)
+                    return "{0}{1} = {2} ? {3} : VK_NULL_HANDLE;\n".format(output, self.name, input_name, handle.driver_handle(input_name))
             elif self.is_generic_handle():
                 if direction == Direction.OUTPUT:
                     LOGGER.err("OUTPUT parameter {0}.{1} cannot be unwrapped".format(self.type, self.name))
@@ -2205,7 +2218,7 @@ class ConversionFunction(object):
                         body += "#endif /* USE_STRUCT_CONVERSION */\n"
 
         elif isinstance(self.operand, VkHandle) and self.direction == Direction.INPUT:
-            body += "        out[i] = " + self.operand.driver_handle("in[i]") + ";\n"
+            body += "        out[i] = in[i] ? " + self.operand.driver_handle("in[i]") + " : VK_NULL_HANDLE;\n"
         else:
             LOGGER.warn("Unhandled conversion operand type")
             body += "        out[i] = in[i];\n"
@@ -2347,7 +2360,7 @@ class ConversionFunction(object):
                         body += "    " + unwrap
                         body += "#endif /* USE_STRUCT_CONVERSION */\n"
         elif isinstance(self.operand, VkHandle) and self.direction == Direction.INPUT:
-            body += "        out[i] = " + self.operand.driver_handle("in[i]") + ";\n"
+            body += "        out[i] = in[i] ? " + self.operand.driver_handle("in[i]") + " : VK_NULL_HANDLE;\n"
         else:
             LOGGER.warn("Unhandled conversion operand type")
             body += "        out[i] = in[i];\n"
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 46a82418fc7..5cd18bbf847 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -25,6 +25,11 @@
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "wine/server.h"
 
 #include "vulkan_private.h"
 #include "winreg.h"
@@ -269,6 +274,15 @@ static struct VkPhysicalDevice_T *wine_vk_physical_device_alloc(struct VkInstanc
      */
     for (i = 0; i < num_host_properties; i++)
     {
+        if (!strcmp(host_properties[i].extensionName, "VK_KHR_external_memory_fd"))
+        {
+            TRACE("Substituting VK_KHR_external_memory_fd for VK_KHR_external_memory_win32\n");
+
+            snprintf(host_properties[i].extensionName, sizeof(host_properties[i].extensionName),
+                    VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);
+            host_properties[i].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
+        }
+
         if (wine_vk_device_extension_supported(host_properties[i].extensionName))
         {
             TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, object);
@@ -428,7 +442,7 @@ static char **parse_xr_extensions(unsigned int *len)
 static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src,
         VkDeviceCreateInfo *dst, BOOL *must_free_extensions)
 {
-    unsigned int i, append_xr = 0, wine_extension_count;
+    unsigned int i, append_xr = 0, replace_win32 = 0, wine_extension_count;
     VkResult res;
 
     static const char *wine_xr_extension_name = "VK_WINE_openxr_device_extensions";
@@ -454,23 +468,38 @@ static VkResult wine_vk_device_convert_create_info(const VkDeviceCreateInfo *src
             break;
         }
     }
-
-    if (append_xr)
+    for (i = 0; i < src->enabledExtensionCount; i++)
+    {
+        if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_memory_win32"))
+        {
+            replace_win32 = 1;
+            break;
+        }
+    }
+    if (append_xr || replace_win32)
     {
-        unsigned int xr_extensions_len, o = 0;
-        char **xr_extensions_list = parse_xr_extensions(&xr_extensions_len);
+        unsigned int xr_extensions_len = 0, o = 0;
+        char **xr_extensions_list = NULL;
+        char **new_extensions_list;
 
-        char **new_extensions_list = malloc(sizeof(char *) * (dst->enabledExtensionCount + xr_extensions_len));
+        if (append_xr)
+            xr_extensions_list = parse_xr_extensions(&xr_extensions_len);
 
-        if(!xr_extensions_list)
+        new_extensions_list = malloc(sizeof(char *) * (dst->enabledExtensionCount + xr_extensions_len));
+
+        if(append_xr && !xr_extensions_list)
             WARN("Requested to use XR extensions, but none are set!\n");
 
         for (i = 0; i < dst->enabledExtensionCount; i++)
         {
-            if (strcmp(dst->ppEnabledExtensionNames[i], wine_xr_extension_name) != 0)
-            {
-                new_extensions_list[o++] = strdup(dst->ppEnabledExtensionNames[i]);
-            }
+            if (append_xr && !strcmp(dst->ppEnabledExtensionNames[i], wine_xr_extension_name))
+                continue;
+
+            if (replace_win32 && !strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_external_memory_win32"))
+                new_extensions_list[o] = strdup("VK_KHR_external_memory_fd");
+            else
+                new_extensions_list[o] = strdup(dst->ppEnabledExtensionNames[i]);
+            ++o;
         }
 
         TRACE("appending XR extensions:\n");
@@ -1402,6 +1431,57 @@ NTSTATUS wine_vkGetPhysicalDeviceExternalFencePropertiesKHR(void *args)
     return STATUS_SUCCESS;
 }
 
+static inline void wine_vk_normalize_handle_types_win(VkExternalMemoryHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
+}
+
+static inline void wine_vk_normalize_handle_types_host(VkExternalMemoryHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT |
+/*      predicated on VK_KHR_external_memory_dma_buf
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT | */
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
+}
+
+static void wine_vk_get_physical_device_external_buffer_properties(VkPhysicalDevice phys_dev,
+        void (*p_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalBufferInfo *, VkExternalBufferProperties *),
+        const VkPhysicalDeviceExternalBufferInfo *buffer_info, VkExternalBufferProperties *properties)
+{
+    VkPhysicalDeviceExternalBufferInfo buffer_info_dup = *buffer_info;
+
+    wine_vk_normalize_handle_types_win(&buffer_info_dup.handleType);
+    if (buffer_info_dup.handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        buffer_info_dup.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+    wine_vk_normalize_handle_types_host(&buffer_info_dup.handleType);
+
+    if (buffer_info->handleType && !buffer_info_dup.handleType)
+    {
+        memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+        return;
+    }
+
+    p_vkGetPhysicalDeviceExternalBufferProperties(phys_dev->phys_dev, &buffer_info_dup, properties);
+
+    if (properties->externalMemoryProperties.exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->externalMemoryProperties.exportFromImportedHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+    wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.exportFromImportedHandleTypes);
+
+    if (properties->externalMemoryProperties.compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->externalMemoryProperties.compatibleHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+    wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.compatibleHandleTypes);
+}
+
 NTSTATUS wine_vkGetPhysicalDeviceExternalBufferProperties(void *args)
 {
     struct vkGetPhysicalDeviceExternalBufferProperties_params *params = args;
@@ -1410,7 +1490,8 @@ NTSTATUS wine_vkGetPhysicalDeviceExternalBufferProperties(void *args)
     VkExternalBufferProperties *properties = params->pExternalBufferProperties;
 
     TRACE("%p, %p, %p\n", phys_dev, buffer_info, properties);
-    memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+
+    wine_vk_get_physical_device_external_buffer_properties(phys_dev, phys_dev->instance->funcs.p_vkGetPhysicalDeviceExternalBufferProperties, buffer_info, properties);
     return STATUS_SUCCESS;
 }
 
@@ -1422,7 +1503,8 @@ NTSTATUS wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *args)
     VkExternalBufferProperties *properties = params->pExternalBufferProperties;
 
     TRACE("%p, %p, %p\n", phys_dev, buffer_info, properties);
-    memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+
+    wine_vk_get_physical_device_external_buffer_properties(phys_dev, phys_dev->instance->funcs.p_vkGetPhysicalDeviceExternalBufferPropertiesKHR, buffer_info, properties);
     return STATUS_SUCCESS;
 }
 
@@ -3404,6 +3486,8 @@ BOOL WINAPI wine_vk_is_available_instance_function(VkInstance instance, const ch
 
 BOOL WINAPI wine_vk_is_available_device_function(VkDevice device, const char *name)
 {
+    if (!strcmp(name, "vkGetMemoryWin32HandleKHR") || !strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
+        name = "vkGetMemoryFdKHR";
     return !!vk_funcs->p_vkGetDeviceProcAddr(device->device, name);
 }
 
@@ -3437,3 +3521,283 @@ VkPhysicalDevice WINAPI __wine_get_wrapped_VkPhysicalDevice(VkInstance instance,
     WARN("Unknown native physical device: %p\n", native_phys_dev);
     return NULL;
 }
+
+static HANDLE create_gpu_resource(int fd, LPCWSTR name)
+{
+    HANDLE ret = INVALID_HANDLE_VALUE;
+
+    TRACE("Creating shared vulkan resource fd %d name %s.\n", fd, debugstr_w(name));
+
+    if (name)
+        FIXME("Naming gpu resources not supported.\n");
+
+    wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &ret);
+
+    return ret;
+}
+
+NTSTATUS wine_vkAllocateMemory(void *args)
+{
+    struct vkAllocateMemory_params *params = args;
+    VkDevice device = params->device;
+    const VkMemoryAllocateInfo *allocate_info = params->pAllocateInfo;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+    VkDeviceMemory *memory = params->pMemory;
+
+    const VkImportMemoryWin32HandleInfoKHR *handle_import_info;
+    const VkExportMemoryWin32HandleInfoKHR *handle_export_info;
+    VkMemoryAllocateInfo allocate_info_dup = *allocate_info;
+    VkExportMemoryAllocateInfo *export_info;
+    VkImportMemoryFdInfoKHR fd_import_info;
+    struct wine_dev_mem *object;
+    VkResult res;
+    int fd;
+
+#if defined(USE_STRUCT_CONVERSION)
+    VkMemoryAllocateInfo_host allocate_info_host;
+    VkMemoryGetFdInfoKHR_host get_fd_info;
+#else
+    VkMemoryAllocateInfo allocate_info_host;
+    VkMemoryGetFdInfoKHR get_fd_info;
+#endif
+
+    TRACE("%p %p %p %p\n", device, allocate_info, allocator, memory);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if ((res = convert_VkMemoryAllocateInfo_struct_chain(allocate_info->pNext, &allocate_info_dup)) < 0)
+    {
+        WARN("Failed to convert VkMemoryAllocateInfo pNext chain, res=%d.\n", res);
+        return res;
+    }
+
+    if (!(object = calloc(1, sizeof(*object))))
+    {
+        free_VkMemoryAllocateInfo_struct_chain(&allocate_info_dup);
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+
+    object->dev_mem = VK_NULL_HANDLE;
+    object->handle = INVALID_HANDLE_VALUE;
+    fd_import_info.fd = -1;
+    fd_import_info.pNext = NULL;
+
+    /* find and process handle import/export info and grab it */
+    handle_import_info = wine_vk_find_struct(allocate_info, IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    handle_export_info = wine_vk_find_struct(allocate_info, EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    if (handle_export_info && handle_export_info->pAttributes && handle_export_info->pAttributes->lpSecurityDescriptor)
+        FIXME("Support for custom security descriptor not implemented.\n");
+
+    if ((export_info = wine_vk_find_struct(&allocate_info_dup, EXPORT_MEMORY_ALLOCATE_INFO)))
+    {
+        object->handle_types = export_info->handleTypes;
+        if (export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            export_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_handle_types_host(&export_info->handleTypes);
+    }
+
+    /* Vulkan consumes imported FDs, but not imported HANDLEs */
+    if (handle_import_info)
+    {
+        fd_import_info.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
+        fd_import_info.pNext = allocate_info_dup.pNext;
+        fd_import_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        switch (handle_import_info->handleType)
+        {
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+                if (handle_import_info->handle)
+                    NtDuplicateObject( NtCurrentProcess(), handle_import_info->handle, NtCurrentProcess(), &object->handle, 0, 0, DUPLICATE_SAME_ACCESS );
+                else if (handle_import_info->name)
+                    FIXME("Importing device memory by resource name not supported.\n");
+                break;
+            default:
+                WARN("Invalid handle type %08x passed in.\n", handle_import_info->handleType);
+                res = VK_ERROR_INVALID_EXTERNAL_HANDLE;
+                goto done;
+        }
+
+        if (object->handle != INVALID_HANDLE_VALUE)
+            wine_server_handle_to_fd(object->handle, FILE_READ_DATA, &fd_import_info.fd, NULL);
+
+        if (fd_import_info.fd == -1)
+        {
+            TRACE("Couldn't access resource handle or name. type=%08x handle=%p name=%s\n", handle_import_info->handleType, handle_import_info->handle,
+                    handle_import_info->name ? debugstr_w(handle_import_info->name) : "");
+            res = VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            goto done;
+        }
+    }
+
+    allocate_info_host.sType = allocate_info_dup.sType;
+    allocate_info_host.pNext = fd_import_info.fd == -1 ? allocate_info_dup.pNext : &fd_import_info;
+    allocate_info_host.allocationSize = allocate_info_dup.allocationSize;
+    allocate_info_host.memoryTypeIndex = allocate_info_dup.memoryTypeIndex;
+
+    if ((res = device->funcs.p_vkAllocateMemory(device->device, &allocate_info_host, NULL, &object->dev_mem)) == VK_SUCCESS)
+    {
+        if (object->handle == INVALID_HANDLE_VALUE && export_info && export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+        {
+            get_fd_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
+            get_fd_info.pNext = NULL;
+            get_fd_info.memory = object->dev_mem;
+            get_fd_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+            if (device->funcs.p_vkGetMemoryFdKHR(device->device, &get_fd_info, &fd) == VK_SUCCESS)
+            {
+                object->handle = create_gpu_resource(fd, handle_export_info ? handle_export_info->name : NULL);
+                object->access = handle_export_info ? handle_export_info->dwAccess : GENERIC_ALL;
+                if (handle_export_info && handle_export_info->pAttributes)
+                    object->inherit = handle_export_info->pAttributes->bInheritHandle;
+                else
+                    object->inherit = FALSE;
+                close(fd);
+            }
+
+            if (object->handle == INVALID_HANDLE_VALUE)
+            {
+                res = VK_ERROR_OUT_OF_HOST_MEMORY;
+                goto done;
+            }
+        }
+
+        WINE_VK_ADD_NON_DISPATCHABLE_MAPPING(device->phys_dev->instance, object, object->dev_mem);
+        *memory = wine_dev_mem_to_handle(object);
+    }
+
+    done:
+
+    if (res != VK_SUCCESS)
+    {
+        device->funcs.p_vkFreeMemory(device->device, object->dev_mem, NULL);
+        if (fd_import_info.fd != -1)
+            close(fd_import_info.fd);
+        if (object->handle != INVALID_HANDLE_VALUE)
+            NtClose(object->handle);
+        free(object);
+    }
+
+    free_VkMemoryAllocateInfo_struct_chain(&allocate_info_dup);
+
+    return res;
+}
+
+NTSTATUS wine_vkGetMemoryWin32HandleKHR(void *args)
+{
+    struct vkGetMemoryWin32HandleKHR_params *params = args;
+    VkDevice device = params->device;
+    const VkMemoryGetWin32HandleInfoKHR *handle_info = params->pGetWin32HandleInfo;
+    HANDLE *handle = params->pHandle;
+
+    struct wine_dev_mem *dev_mem = wine_dev_mem_from_handle(handle_info->memory);
+    const VkBaseInStructure *chain;
+
+    TRACE("%p, %p %p\n", device, handle_info, handle);
+
+    if (!(dev_mem->handle_types & handle_info->handleType))
+        return VK_ERROR_UNKNOWN;
+
+    if ((chain = handle_info->pNext))
+        FIXME("Ignoring a linked structure of type %u.\n", chain->sType);
+
+    switch(handle_info->handleType)
+    {
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+            return !NtDuplicateObject( NtCurrentProcess(), dev_mem->handle, NtCurrentProcess(), handle, dev_mem->access, dev_mem->inherit ? OBJ_INHERIT : 0, 0) ?
+                VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
+        default:
+            FIXME("Unable to get handle of type %x, did the application ignore the capabilities?\n", handle_info->handleType);
+            return VK_ERROR_UNKNOWN;
+    }
+}
+
+NTSTATUS wine_vkFreeMemory(void *args)
+{
+    struct vkFreeMemory_params *params = args;
+    VkDevice device = params->device;
+    VkDeviceMemory handle = params->memory;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+
+    struct wine_dev_mem *dev_mem = wine_dev_mem_from_handle(handle);
+
+    TRACE("%p 0x%s, %p\n", device, wine_dbgstr_longlong(handle), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (!handle)
+        return STATUS_SUCCESS;
+
+    WINE_VK_REMOVE_HANDLE_MAPPING(device->phys_dev->instance, dev_mem);
+    device->funcs.p_vkFreeMemory(device->device, dev_mem->dev_mem, NULL);
+    if (dev_mem->handle != INVALID_HANDLE_VALUE)
+        NtClose(dev_mem->handle);
+    free(dev_mem);
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS wine_vkGetMemoryWin32HandlePropertiesKHR(void *args)
+{
+    struct vkGetMemoryWin32HandlePropertiesKHR_params *params = args;
+    VkDevice device = params->device;
+    VkExternalMemoryHandleTypeFlagBits type = params->handleType;
+    HANDLE handle = params->handle;
+    VkMemoryWin32HandlePropertiesKHR *properties = params->pMemoryWin32HandleProperties;
+
+    TRACE("%p %u %p %p\n", device, type, handle, properties);
+
+    /* VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-00666
+       handleType must not be one of the handle types defined as opaque */
+    return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+}
+
+NTSTATUS wine_vkCreateBuffer(void *args)
+{
+    struct vkCreateBuffer_params *params = args;
+    VkDevice device = params->device;
+    const VkBufferCreateInfo *create_info = params->pCreateInfo;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+    VkBuffer *buffer = params->pBuffer;
+
+    VkExternalMemoryBufferCreateInfo *external_memory_info;
+    VkResult res;
+
+#if defined(USE_STRUCT_CONVERSION)
+    VkBufferCreateInfo_host create_info_host;
+#else
+    VkBufferCreateInfo create_info_host;
+#endif
+
+    TRACE("%p %p %p %p\n", device, create_info, allocator, buffer);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if ((res = convert_VkBufferCreateInfo_struct_chain(create_info->pNext, (VkBufferCreateInfo *) &create_info_host)))
+    {
+        WARN("Failed to convert VkBufferCreateInfo pNext chain, res=%d.\n", res);
+        return res;
+    }
+
+    if ((external_memory_info = wine_vk_find_struct(&create_info_host, EXTERNAL_MEMORY_BUFFER_CREATE_INFO)))
+    {
+        if (external_memory_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            external_memory_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_handle_types_host(&external_memory_info->handleTypes);
+    }
+
+    create_info_host.sType = create_info->sType;
+    create_info_host.flags = create_info->flags;
+    create_info_host.size = create_info->size;
+    create_info_host.usage = create_info->usage;
+    create_info_host.sharingMode = create_info->sharingMode;
+    create_info_host.queueFamilyIndexCount = create_info->queueFamilyIndexCount;
+    create_info_host.pQueueFamilyIndices = create_info->pQueueFamilyIndices;
+
+    res = device->funcs.p_vkCreateBuffer(device->device, &create_info_host, NULL, buffer);
+
+    free_VkBufferCreateInfo_struct_chain((VkBufferCreateInfo *) &create_info_host);
+
+    return res;
+}
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 491e4cbe4a7..0946c3629dd 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -242,6 +242,30 @@ static inline VkSurfaceKHR wine_surface_to_handle(struct wine_surface *surface)
     return (VkSurfaceKHR)(uintptr_t)surface;
 }
 
+struct wine_dev_mem
+{
+    VkDeviceMemory dev_mem;
+
+    VkExternalMemoryHandleTypeFlagBits handle_types;
+
+    BOOL inherit;
+    DWORD access;
+
+    HANDLE handle;
+
+    struct wine_vk_mapping mapping;
+};
+
+static inline struct wine_dev_mem *wine_dev_mem_from_handle(VkDeviceMemory handle)
+{
+    return (struct wine_dev_mem *)(uintptr_t)handle;
+}
+
+static inline VkDeviceMemory wine_dev_mem_to_handle(struct wine_dev_mem *dev_mem)
+{
+    return (VkDeviceMemory)(uintptr_t)dev_mem;
+}
+
 BOOL wine_vk_device_extension_supported(const char *name) DECLSPEC_HIDDEN;
 BOOL wine_vk_instance_extension_supported(const char *name) DECLSPEC_HIDDEN;
 
From 88156f70f9e9ae5ddf3c0b2ec066b64ac4a6805e Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 19 May 2021 13:38:12 -0400
Subject: [PATCH] winevulkan: Implement VK_KHR_external_memory_win32 for
 images.

Signed-off-by: Derek Lesho <dlesho@codeweavers.com>
---
 dlls/winevulkan/make_vulkan |   3 +
 dlls/winevulkan/vulkan.c    | 111 ++++++++++++++++++++++++++++--------
 2 files changed, 91 insertions(+), 23 deletions(-)

diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index fc5f1e621b4..2434ee728c6 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -219,6 +219,7 @@ FUNCTION_OVERRIDES = {
     "vkCreateCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkCreateComputePipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
     "vkCreateGraphicsPipelines" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.PRIVATE},
+    "vkCreateImage" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyCommandPool" : {"dispatch": True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkDestroyDevice" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
     "vkFreeCommandBuffers" : {"dispatch" : True, "driver" : False, "thunk" : ThunkType.NONE},
@@ -297,7 +298,9 @@ STRUCT_CHAIN_CONVERSIONS = {
 
     # Structs which require pNext chain modification
     "VkBufferCreateInfo": [],
+    "VkImageCreateInfo": [],
     "VkMemoryAllocateInfo": ["VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"],
+    "VkPhysicalDeviceImageFormatInfo2": [],
 }
 
 
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 5cd18bbf847..ea8cc38fbb2 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -1508,52 +1508,80 @@ NTSTATUS wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *args)
     return STATUS_SUCCESS;
 }
 
-NTSTATUS wine_vkGetPhysicalDeviceImageFormatProperties2(void *args)
+static VkResult wine_vk_get_physical_device_image_format_properties_2(VkPhysicalDevice phys_dev,
+        VkResult (*p_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice, const VkPhysicalDeviceImageFormatInfo2 *, VkImageFormatProperties2 *),
+        const VkPhysicalDeviceImageFormatInfo2 *format_info, VkImageFormatProperties2 *properties)
 {
-    struct vkGetPhysicalDeviceImageFormatProperties2_params *params = args;
-    VkPhysicalDevice phys_dev = params->physicalDevice;
-    const VkPhysicalDeviceImageFormatInfo2 *format_info = params->pImageFormatInfo;
-    VkImageFormatProperties2 *properties = params->pImageFormatProperties;
+    VkPhysicalDeviceExternalImageFormatInfo *external_image_info_dup = NULL;
+    const VkPhysicalDeviceExternalImageFormatInfo *external_image_info;
+    VkPhysicalDeviceImageFormatInfo2 format_info_host = *format_info;
     VkExternalImageFormatProperties *external_image_properties;
     VkResult res;
 
-    TRACE("%p, %p, %p\n", phys_dev, format_info, properties);
+    if ((external_image_info = wine_vk_find_struct(format_info, PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO)) && external_image_info->handleType)
+    {
+        if ((res = convert_VkPhysicalDeviceImageFormatInfo2_struct_chain(format_info->pNext, &format_info_host)) < 0)
+        {
+            WARN("Failed to convert VkPhysicalDeviceImageFormatInfo2 pNext chain, res=%d.\n", res);
+            return res;
+        }
+        external_image_info_dup = wine_vk_find_struct(&format_info_host, PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO);
+
+        wine_vk_normalize_handle_types_win(&external_image_info_dup->handleType);
+
+        if (external_image_info_dup->handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            external_image_info_dup->handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        wine_vk_normalize_handle_types_host(&external_image_info_dup->handleType);
+        if (!external_image_info_dup->handleType)
+        {
+            WARN("Unsupported handle type %#x.\n", external_image_info->handleType);
+            return VK_ERROR_FORMAT_NOT_SUPPORTED;
+        }
+    }
 
-    res = thunk_vkGetPhysicalDeviceImageFormatProperties2(phys_dev, format_info, properties);
+    res = p_vkGetPhysicalDeviceImageFormatProperties2(phys_dev, &format_info_host, properties);
+
+    if (external_image_info_dup)
+        free_VkPhysicalDeviceImageFormatInfo2_struct_chain(&format_info_host);
 
     if ((external_image_properties = wine_vk_find_struct(properties, EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
     {
         VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
-        p->externalMemoryFeatures = 0;
-        p->exportFromImportedHandleTypes = 0;
-        p->compatibleHandleTypes = 0;
+        if (p->exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->exportFromImportedHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        wine_vk_normalize_handle_types_win(&p->exportFromImportedHandleTypes);
+
+        if (p->compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->compatibleHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        wine_vk_normalize_handle_types_win(&p->compatibleHandleTypes);
     }
 
     return res;
 }
 
-NTSTATUS wine_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
+NTSTATUS wine_vkGetPhysicalDeviceImageFormatProperties2(void *args)
 {
-    struct vkGetPhysicalDeviceImageFormatProperties2KHR_params *params = args;
+    struct vkGetPhysicalDeviceImageFormatProperties2_params *params = args;
     VkPhysicalDevice phys_dev = params->physicalDevice;
     const VkPhysicalDeviceImageFormatInfo2 *format_info = params->pImageFormatInfo;
     VkImageFormatProperties2 *properties = params->pImageFormatProperties;
-    VkExternalImageFormatProperties *external_image_properties;
-    VkResult res;
 
     TRACE("%p, %p, %p\n", phys_dev, format_info, properties);
 
-    res = thunk_vkGetPhysicalDeviceImageFormatProperties2KHR(phys_dev, format_info, properties);
+    return wine_vk_get_physical_device_image_format_properties_2(phys_dev, thunk_vkGetPhysicalDeviceImageFormatProperties2, format_info, properties);
+}
 
-    if ((external_image_properties = wine_vk_find_struct(properties, EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
-    {
-        VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
-        p->externalMemoryFeatures = 0;
-        p->exportFromImportedHandleTypes = 0;
-        p->compatibleHandleTypes = 0;
-    }
+NTSTATUS wine_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
+{
+    struct vkGetPhysicalDeviceImageFormatProperties2KHR_params *params = args;
+    VkPhysicalDevice phys_dev = params->physicalDevice;
+    const VkPhysicalDeviceImageFormatInfo2 *format_info = params->pImageFormatInfo;
+    VkImageFormatProperties2 *properties = params->pImageFormatProperties;
 
-    return res;
+    TRACE("%p, %p, %p\n", phys_dev, format_info, properties);
+
+    return wine_vk_get_physical_device_image_format_properties_2(phys_dev, thunk_vkGetPhysicalDeviceImageFormatProperties2KHR, format_info, properties);
 }
 
 /* From ntdll/unix/sync.c */
@@ -3801,3 +3829,40 @@ NTSTATUS wine_vkCreateBuffer(void *args)
 
     return res;
 }
+
+NTSTATUS wine_vkCreateImage(void *args)
+{
+    struct vkCreateImage_params *params = args;
+    VkDevice device = params->device;
+    const VkImageCreateInfo *create_info = params->pCreateInfo;
+    const VkAllocationCallbacks *allocator = params->pAllocator;
+    VkImage *image = params->pImage;
+
+    VkExternalMemoryImageCreateInfo *external_memory_info;
+    VkImageCreateInfo create_info_host = *create_info;
+    VkResult res;
+
+    TRACE("%p %p %p %p\n", device, create_info, allocator, image);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if ((res = convert_VkImageCreateInfo_struct_chain(create_info->pNext, &create_info_host)))
+    {
+        WARN("Failed to convert VkImageCreateInfo pNext chain, res=%d.\n", res);
+        return res;
+    }
+
+    if ((external_memory_info = wine_vk_find_struct(&create_info_host, EXTERNAL_MEMORY_IMAGE_CREATE_INFO)))
+    {
+        if (external_memory_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR)
+            external_memory_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
+        wine_vk_normalize_handle_types_host(&external_memory_info->handleTypes);
+    }
+
+    res = device->funcs.p_vkCreateImage(device->device, &create_info_host, NULL, image);
+
+    free_VkImageCreateInfo_struct_chain(&create_info_host);
+
+    return res;
+}
From 45f875390fac9137fb6a9cd98ce0d1e7b7d5e19f Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 13 Oct 2021 13:16:44 +0200
Subject: [PATCH] winevulkan: Implement support for KMT handles and named
 objects.

---
 configure.ac                                |   1 +
 dlls/sharedgpures.sys/Makefile.in           |   6 +
 dlls/sharedgpures.sys/shared_resource.c     | 348 ++++++++++++++++++++
 dlls/sharedgpures.sys/sharedgpures.sys.spec |   1 +
 dlls/winevulkan/vulkan.c                    | 190 ++++++++++-
 dlls/winevulkan/vulkan_private.h            |   7 +
 include/ddk/wdm.h                           |   1 +
 loader/wine.inf.in                          |  13 +
 8 files changed, 552 insertions(+), 15 deletions(-)
 create mode 100644 dlls/sharedgpures.sys/Makefile.in
 create mode 100644 dlls/sharedgpures.sys/shared_resource.c
 create mode 100644 dlls/sharedgpures.sys/sharedgpures.sys.spec

diff --git a/configure.ac b/configure.ac
index 8fb753726ba..e860c8853bc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3290,6 +3290,7 @@ WINE_CONFIG_MAKEFILE(dlls/setupapi/tests)
 WINE_CONFIG_MAKEFILE(dlls/setupx.dll16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/sfc)
 WINE_CONFIG_MAKEFILE(dlls/sfc_os)
+WINE_CONFIG_MAKEFILE(dlls/sharedgpures.sys)
 WINE_CONFIG_MAKEFILE(dlls/shcore)
 WINE_CONFIG_MAKEFILE(dlls/shcore/tests)
 WINE_CONFIG_MAKEFILE(dlls/shdoclc)
diff --git a/dlls/sharedgpures.sys/Makefile.in b/dlls/sharedgpures.sys/Makefile.in
new file mode 100644
index 00000000000..2d64a476826
--- /dev/null
+++ b/dlls/sharedgpures.sys/Makefile.in
@@ -0,0 +1,6 @@
+MODULE    = sharedgpures.sys
+IMPORTS   = ntoskrnl
+EXTRADLLFLAGS = -Wl,--subsystem,native -mno-cygwin
+
+C_SRCS = \
+	shared_resource.c
diff --git a/dlls/sharedgpures.sys/shared_resource.c b/dlls/sharedgpures.sys/shared_resource.c
new file mode 100644
index 00000000000..0ff16385b4f
--- /dev/null
+++ b/dlls/sharedgpures.sys/shared_resource.c
@@ -0,0 +1,348 @@
+#include <stdarg.h>
+
+#define NONAMELESSUNION
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "winioctl.h"
+
+#include "ddk/wdm.h"
+
+#include "wine/debug.h"
+#include "wine/list.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(sharedgpures);
+
+static DRIVER_OBJECT *sharedgpures_driver;
+
+struct shared_resource
+{
+    unsigned int ref_count;
+    void *unix_resource;
+    WCHAR *name;
+};
+
+static struct shared_resource *resource_pool;
+static unsigned int resource_pool_size;
+
+/* TODO: If/when ntoskrnl gets support for referencing user handles directly, remove this function */
+static void *reference_client_handle(obj_handle_t handle)
+{
+    HANDLE client_process, kernel_handle;
+    OBJECT_ATTRIBUTES attr;
+    void *object = NULL;
+    CLIENT_ID cid;
+
+    attr.Length = sizeof(OBJECT_ATTRIBUTES);
+    attr.RootDirectory = 0;
+    attr.Attributes = OBJ_KERNEL_HANDLE;
+    attr.ObjectName = NULL;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    cid.UniqueProcess = PsGetCurrentProcessId();
+    cid.UniqueThread = 0;
+
+    if (NtOpenProcess(&client_process, PROCESS_ALL_ACCESS, &attr, &cid) != STATUS_SUCCESS)
+        return NULL;
+
+    if (NtDuplicateObject(client_process, wine_server_ptr_handle(handle), NtCurrentProcess(), &kernel_handle,
+                               0, OBJ_KERNEL_HANDLE, DUPLICATE_SAME_ACCESS) != STATUS_SUCCESS)
+    {
+        NtClose(client_process);
+        return NULL;
+    }
+
+    ObReferenceObjectByHandle(kernel_handle, 0, NULL, KernelMode, &object, NULL);
+
+    NtClose(client_process);
+    NtClose(kernel_handle);
+
+    return object;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_CREATE           CTL_CODE(FILE_DEVICE_VIDEO, 0, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_create
+{
+    obj_handle_t unix_handle;
+    WCHAR name[1];
+};
+
+static NTSTATUS shared_resource_create(struct shared_resource **res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_create *input = buff;
+    void *unix_resource;
+    unsigned int i;
+    LPWSTR name;
+
+    if (insize < sizeof(*input))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (input->name[ ((insize - offsetof(struct shared_resource_create, name)) / sizeof(WCHAR)) - 1 ])
+        return STATUS_INVALID_PARAMETER;
+
+    if (!(unix_resource = reference_client_handle(input->unix_handle)))
+        return STATUS_INVALID_HANDLE;
+
+    if (insize == sizeof(*input))
+        name = NULL;
+    else
+    {
+        name = ExAllocatePoolWithTag(NonPagedPool, insize - offsetof(struct shared_resource_create, name), 0);
+        wcscpy(name, &input->name[0]);
+    }
+
+    for (i = 0; i < resource_pool_size; i++)
+        if (!resource_pool[i].ref_count)
+            break;
+
+    if (i == resource_pool_size)
+    {
+        struct shared_resource *expanded_pool =
+            ExAllocatePoolWithTag(NonPagedPool, sizeof(struct shared_resource) * (resource_pool_size + 1024), 0);
+
+        if (resource_pool)
+        {
+            memcpy(expanded_pool, resource_pool, resource_pool_size * sizeof(struct shared_resource));
+            ExFreePoolWithTag(resource_pool, 0);
+        }
+
+        memset(&expanded_pool[resource_pool_size], 0, 1024 * sizeof (struct shared_resource));
+
+        resource_pool = expanded_pool;
+        resource_pool_size += 1024;
+    }
+
+    *res = &resource_pool[i];
+    (*res)->ref_count = 1;
+    (*res)->unix_resource = unix_resource;
+    (*res)->name = name;
+
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_OPEN             CTL_CODE(FILE_DEVICE_VIDEO, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_open
+{
+    obj_handle_t kmt_handle;
+    WCHAR name[1];
+};
+
+static unsigned int kmt_to_index(obj_handle_t kmt)
+{
+    if (!(kmt & 0x40000000) || (kmt - 2) % 4)
+        return -1;
+    return (((unsigned int) kmt & ~0x40000000) - 2) / 4;
+}
+
+static NTSTATUS shared_resource_open(struct shared_resource **res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_open *input = buff;
+    unsigned int i;
+
+    if (insize < sizeof(*input))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (input->kmt_handle)
+    {
+        if (kmt_to_index(input->kmt_handle) >= resource_pool_size)
+            return STATUS_INVALID_HANDLE;
+
+        *res = &resource_pool[kmt_to_index(input->kmt_handle)];
+    }
+    else
+    {
+        if (input->name[ ((insize - offsetof(struct shared_resource_open, name)) / sizeof(WCHAR)) - 1 ])
+            return STATUS_INVALID_PARAMETER;
+
+        /* name lookup */
+        for (i = 0; i < resource_pool_size; i++)
+        {
+            if (!wcscmp(resource_pool[i].name, &input->name[0]))
+            {
+                *res = &resource_pool[i];
+                break;
+            }
+        }
+
+        if (i == resource_pool_size)
+            return STATUS_OBJECT_NAME_NOT_FOUND;
+    }
+
+    (*res)->ref_count++;
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GETKMT           CTL_CODE(FILE_DEVICE_VIDEO, 2, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static obj_handle_t index_to_kmt(unsigned int idx)
+{
+    return (idx * 4 + 2) | 0x40000000;
+}
+
+static NTSTATUS shared_resource_getkmt(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    if (outsize < sizeof(unsigned int))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    *((unsigned int *)buff) = index_to_kmt(res - resource_pool);
+
+    iosb->Information = sizeof(unsigned int);
+    return STATUS_SUCCESS;
+}
+
+/* TODO: If/when ntoskrnl gets support for opening user handles directly, remove this function */
+static obj_handle_t open_client_handle(void *object)
+{
+    HANDLE client_process, kernel_handle, handle = NULL;
+    OBJECT_ATTRIBUTES attr;
+    CLIENT_ID cid;
+
+    attr.Length = sizeof(OBJECT_ATTRIBUTES);
+    attr.RootDirectory = 0;
+    attr.Attributes = OBJ_KERNEL_HANDLE;
+    attr.ObjectName = NULL;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    cid.UniqueProcess = PsGetCurrentProcessId();
+    cid.UniqueThread = 0;
+
+    if (NtOpenProcess(&client_process, PROCESS_ALL_ACCESS, &attr, &cid) != STATUS_SUCCESS)
+        return 0;
+
+    if (ObOpenObjectByPointer(object, 0, NULL, GENERIC_ALL, NULL, KernelMode, &kernel_handle) != STATUS_SUCCESS)
+    {
+        NtClose(client_process);
+        return 0;
+    }
+
+    NtDuplicateObject(NtCurrentProcess(), kernel_handle, client_process, &handle,
+                        0, 0, DUPLICATE_SAME_ACCESS);
+
+    NtClose(client_process);
+    NtClose(kernel_handle);
+
+    return wine_server_obj_handle(handle);
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE           CTL_CODE(FILE_DEVICE_VIDEO, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static NTSTATUS shared_resource_get_unix_resource(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    if (outsize < sizeof(obj_handle_t))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    *((obj_handle_t *)buff) = open_client_handle(res->unix_resource);
+
+    iosb->Information = sizeof(obj_handle_t);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
+{
+    irp->IoStatus.u.Status = STATUS_SUCCESS;
+    IoCompleteRequest(irp, IO_NO_INCREMENT);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
+{
+    IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation(irp);
+    struct shared_resource *res = stack->FileObject->FsContext;
+
+    TRACE("Freeing shared resouce %p.\n", res);
+
+    if (res)
+    {
+        res->ref_count--;
+        if (!res->ref_count && res->unix_resource)
+        {
+            /* TODO: see if its possible to destroy the object here (unlink?) */
+            ObDereferenceObject(res->unix_resource);
+            res->unix_resource = NULL;
+        }
+    }
+
+    irp->IoStatus.u.Status = STATUS_SUCCESS;
+    IoCompleteRequest(irp, IO_NO_INCREMENT);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
+{
+    IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
+    struct shared_resource **res = (struct shared_resource **) &stack->FileObject->FsContext;
+    NTSTATUS status;
+
+    TRACE( "ioctl %x insize %u outsize %u\n",
+           stack->Parameters.DeviceIoControl.IoControlCode,
+           stack->Parameters.DeviceIoControl.InputBufferLength,
+           stack->Parameters.DeviceIoControl.OutputBufferLength );
+
+    switch (stack->Parameters.DeviceIoControl.IoControlCode)
+    {
+        case IOCTL_SHARED_GPU_RESOURCE_CREATE:
+            status = shared_resource_create( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_OPEN:
+            status = shared_resource_open( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GETKMT:
+            status = shared_resource_getkmt( *res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE:
+            status = shared_resource_get_unix_resource( *res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
+    default:
+        FIXME( "ioctl %x not supported\n", stack->Parameters.DeviceIoControl.IoControlCode );
+        status = STATUS_NOT_SUPPORTED;
+        break;
+    }
+
+    irp->IoStatus.u.Status = status;
+    IoCompleteRequest( irp, IO_NO_INCREMENT );
+    return status;
+}
+
+NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
+{
+    static const WCHAR device_nameW[] = L"\\Device\\SharedGpuResource";
+    static const WCHAR link_nameW[] = L"\\??\\SharedGpuResource";
+    UNICODE_STRING device_name, link_name;
+    DEVICE_OBJECT *device;
+    NTSTATUS status;
+
+    sharedgpures_driver = driver;
+
+    driver->MajorFunction[IRP_MJ_CREATE] = dispatch_create;
+    driver->MajorFunction[IRP_MJ_CLOSE] = dispatch_close;
+    driver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = dispatch_ioctl;
+
+    RtlInitUnicodeString(&device_name, device_nameW);
+    RtlInitUnicodeString(&link_name, link_nameW);
+
+    if ((status = IoCreateDevice(driver, 0, &device_name, 0, 0, FALSE, &device)))
+        return status;
+
+    return IoCreateSymbolicLink(&link_name, &device_name);
+}
diff --git a/dlls/sharedgpures.sys/sharedgpures.sys.spec b/dlls/sharedgpures.sys/sharedgpures.sys.spec
new file mode 100644
index 00000000000..76421d7e35b
--- /dev/null
+++ b/dlls/sharedgpures.sys/sharedgpures.sys.spec
@@ -0,0 +1 @@
+# nothing to export
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index ea8cc38fbb2..4b705103fb5 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -29,6 +29,9 @@
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
+#include "windef.h"
+#include "winnt.h"
+#include "winioctl.h"
 #include "wine/server.h"
 
 #include "vulkan_private.h"
@@ -1454,6 +1457,10 @@ static inline void wine_vk_normalize_handle_types_host(VkExternalMemoryHandleTyp
         VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
 }
 
+static const VkExternalMemoryHandleTypeFlagBits wine_vk_handle_over_fd_types =
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
+
 static void wine_vk_get_physical_device_external_buffer_properties(VkPhysicalDevice phys_dev,
         void (*p_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalBufferInfo *, VkExternalBufferProperties *),
         const VkPhysicalDeviceExternalBufferInfo *buffer_info, VkExternalBufferProperties *properties)
@@ -1461,7 +1468,7 @@ static void wine_vk_get_physical_device_external_buffer_properties(VkPhysicalDev
     VkPhysicalDeviceExternalBufferInfo buffer_info_dup = *buffer_info;
 
     wine_vk_normalize_handle_types_win(&buffer_info_dup.handleType);
-    if (buffer_info_dup.handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+    if (buffer_info_dup.handleType & wine_vk_handle_over_fd_types)
         buffer_info_dup.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
     wine_vk_normalize_handle_types_host(&buffer_info_dup.handleType);
 
@@ -1474,11 +1481,11 @@ static void wine_vk_get_physical_device_external_buffer_properties(VkPhysicalDev
     p_vkGetPhysicalDeviceExternalBufferProperties(phys_dev->phys_dev, &buffer_info_dup, properties);
 
     if (properties->externalMemoryProperties.exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
-        properties->externalMemoryProperties.exportFromImportedHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        properties->externalMemoryProperties.exportFromImportedHandleTypes |= wine_vk_handle_over_fd_types;
     wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.exportFromImportedHandleTypes);
 
     if (properties->externalMemoryProperties.compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
-        properties->externalMemoryProperties.compatibleHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+        properties->externalMemoryProperties.compatibleHandleTypes |= wine_vk_handle_over_fd_types;
     wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.compatibleHandleTypes);
 }
 
@@ -1529,7 +1536,7 @@ static VkResult wine_vk_get_physical_device_image_format_properties_2(VkPhysical
 
         wine_vk_normalize_handle_types_win(&external_image_info_dup->handleType);
 
-        if (external_image_info_dup->handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        if (external_image_info_dup->handleType & wine_vk_handle_over_fd_types)
             external_image_info_dup->handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
 
         wine_vk_normalize_handle_types_host(&external_image_info_dup->handleType);
@@ -1549,11 +1556,11 @@ static VkResult wine_vk_get_physical_device_image_format_properties_2(VkPhysical
     {
         VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
         if (p->exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
-            p->exportFromImportedHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+            p->exportFromImportedHandleTypes |= wine_vk_handle_over_fd_types;
         wine_vk_normalize_handle_types_win(&p->exportFromImportedHandleTypes);
 
         if (p->compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
-            p->compatibleHandleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+            p->compatibleHandleTypes |= wine_vk_handle_over_fd_types;
         wine_vk_normalize_handle_types_win(&p->compatibleHandleTypes);
     }
 
@@ -3550,18 +3557,154 @@ VkPhysicalDevice WINAPI __wine_get_wrapped_VkPhysicalDevice(VkInstance instance,
     return NULL;
 }
 
+#define IOCTL_SHARED_GPU_RESOURCE_CREATE           CTL_CODE(FILE_DEVICE_VIDEO, 0, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_create
+{
+    obj_handle_t unix_handle;
+    WCHAR name[1];
+};
+
 static HANDLE create_gpu_resource(int fd, LPCWSTR name)
 {
-    HANDLE ret = INVALID_HANDLE_VALUE;
+    static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
+    HANDLE unix_resource = INVALID_HANDLE_VALUE;
+    struct shared_resource_create *inbuff;
+    UNICODE_STRING shared_gpu_resource_us;
+    HANDLE shared_resource;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+    DWORD in_size;
 
     TRACE("Creating shared vulkan resource fd %d name %s.\n", fd, debugstr_w(name));
 
+    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &unix_resource) != STATUS_SUCCESS)
+        return INVALID_HANDLE_VALUE;
+
+    init_unicode_string(&shared_gpu_resource_us, shared_gpu_resourceW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = 0;
+    attr.ObjectName = &shared_gpu_resource_us;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if ((status = NtCreateFile(&shared_resource, GENERIC_READ | GENERIC_WRITE, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0)))
+    {
+        ERR("Failed to load open a shared resource handle, status %#x.\n", status);
+        NtClose(unix_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    in_size = sizeof(*inbuff) + (name ? lstrlenW(name) * sizeof(WCHAR) : 0);
+    inbuff = calloc(1, in_size);
+    inbuff->unix_handle = wine_server_obj_handle(unix_resource);
+    if (name)
+        lstrcpyW(&inbuff->name[0], name);
+
+    if ((status = NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_CREATE,
+            inbuff, in_size, NULL, 0)))
+
+    free(inbuff);
+    NtClose(unix_resource);
+
+    if (status)
+    {
+        ERR("Failed to create video resource, status %#x.\n", status);
+        NtClose(shared_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    return shared_resource;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_OPEN             CTL_CODE(FILE_DEVICE_VIDEO, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_open
+{
+    obj_handle_t kmt_handle;
+    WCHAR name[1];
+};
+
+static HANDLE open_shared_resource(HANDLE kmt_handle, LPCWSTR name)
+{
+    static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
+    UNICODE_STRING shared_gpu_resource_us;
+    struct shared_resource_open *inbuff;
+    HANDLE shared_resource;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+    DWORD in_size;
+
+    init_unicode_string(&shared_gpu_resource_us, shared_gpu_resourceW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = 0;
+    attr.ObjectName = &shared_gpu_resource_us;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if ((status = NtCreateFile(&shared_resource, GENERIC_READ | GENERIC_WRITE, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0)))
+    {
+        ERR("Failed to load open a shared resource handle, status %#x.\n", status);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    in_size = sizeof(*inbuff) + (name ? lstrlenW(name) * sizeof(WCHAR) : 0);
+    inbuff = calloc(1, in_size);
+    inbuff->kmt_handle = wine_server_obj_handle(kmt_handle);
     if (name)
-        FIXME("Naming gpu resources not supported.\n");
+        lstrcpyW(&inbuff->name[0], name);
+
+    status = NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_OPEN,
+            inbuff, in_size, NULL, 0);
 
-    wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &ret);
+    free(inbuff);
 
-    return ret;
+    if (status)
+    {
+        ERR("Failed to open video resource, status %#x.\n", status);
+        NtClose(shared_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    return shared_resource;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE           CTL_CODE(FILE_DEVICE_VIDEO, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static int get_shared_resource_fd(HANDLE shared_resource)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t unix_resource;
+    NTSTATUS status;
+    int ret;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE,
+            NULL, 0, &unix_resource, sizeof(unix_resource)))
+        return -1;
+
+    status = wine_server_handle_to_fd(wine_server_ptr_handle(unix_resource), FILE_READ_DATA, &ret, NULL);
+    NtClose(wine_server_ptr_handle(unix_resource));
+    return status == STATUS_SUCCESS ? ret : -1;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GETKMT           CTL_CODE(FILE_DEVICE_VIDEO, 2, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static HANDLE get_shared_resource_kmt_handle(HANDLE shared_resource)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t kmt_handle;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GETKMT,
+            NULL, 0, &kmt_handle, sizeof(kmt_handle)))
+        return INVALID_HANDLE_VALUE;
+
+    return wine_server_ptr_handle(kmt_handle);
 }
 
 NTSTATUS wine_vkAllocateMemory(void *args)
@@ -3620,7 +3763,7 @@ NTSTATUS wine_vkAllocateMemory(void *args)
     if ((export_info = wine_vk_find_struct(&allocate_info_dup, EXPORT_MEMORY_ALLOCATE_INFO)))
     {
         object->handle_types = export_info->handleTypes;
-        if (export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        if (export_info->handleTypes & wine_vk_handle_over_fd_types)
             export_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
         wine_vk_normalize_handle_types_host(&export_info->handleTypes);
     }
@@ -3638,7 +3781,16 @@ NTSTATUS wine_vkAllocateMemory(void *args)
                 if (handle_import_info->handle)
                     NtDuplicateObject( NtCurrentProcess(), handle_import_info->handle, NtCurrentProcess(), &object->handle, 0, 0, DUPLICATE_SAME_ACCESS );
                 else if (handle_import_info->name)
-                    FIXME("Importing device memory by resource name not supported.\n");
+                    object->handle = open_shared_resource( 0, handle_import_info->name );
+                break;
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+                /* FIXME: the spec says that device memory imported from a KMT handle doesn't keep a reference to the underyling payload.
+                   This means that in cases where on windows an application leaks VkDeviceMemory objects, we leak the full payload.  To
+                   fix this, we would need wine_dev_mem objects to store no reference to the payload, that means no host VkDeviceMemory
+                   object (as objects imported from FDs hold a reference to the payload), and no win32 handle to the object. We would then
+                   extend make_vulkan to have the thunks converting wine_dev_mem to native handles open the VkDeviceMemory from the KMT
+                   handle, use it in the host function, then close it again. */
+                object->handle = open_shared_resource( handle_import_info->handle, NULL );
                 break;
             default:
                 WARN("Invalid handle type %08x passed in.\n", handle_import_info->handleType);
@@ -3647,7 +3799,7 @@ NTSTATUS wine_vkAllocateMemory(void *args)
         }
 
         if (object->handle != INVALID_HANDLE_VALUE)
-            wine_server_handle_to_fd(object->handle, FILE_READ_DATA, &fd_import_info.fd, NULL);
+            fd_import_info.fd = get_shared_resource_fd(object->handle);
 
         if (fd_import_info.fd == -1)
         {
@@ -3720,6 +3872,7 @@ NTSTATUS wine_vkGetMemoryWin32HandleKHR(void *args)
 
     struct wine_dev_mem *dev_mem = wine_dev_mem_from_handle(handle_info->memory);
     const VkBaseInStructure *chain;
+    HANDLE ret;
 
     TRACE("%p, %p %p\n", device, handle_info, handle);
 
@@ -3734,6 +3887,13 @@ NTSTATUS wine_vkGetMemoryWin32HandleKHR(void *args)
         case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
             return !NtDuplicateObject( NtCurrentProcess(), dev_mem->handle, NtCurrentProcess(), handle, dev_mem->access, dev_mem->inherit ? OBJ_INHERIT : 0, 0) ?
                 VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+        {
+            if ((ret = get_shared_resource_kmt_handle(dev_mem->handle)) == INVALID_HANDLE_VALUE)
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            *handle = ret;
+            return VK_SUCCESS;
+        }
         default:
             FIXME("Unable to get handle of type %x, did the application ignore the capabilities?\n", handle_info->handleType);
             return VK_ERROR_UNKNOWN;
@@ -3810,7 +3970,7 @@ NTSTATUS wine_vkCreateBuffer(void *args)
 
     if ((external_memory_info = wine_vk_find_struct(&create_info_host, EXTERNAL_MEMORY_BUFFER_CREATE_INFO)))
     {
-        if (external_memory_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+        if (external_memory_info->handleTypes & wine_vk_handle_over_fd_types)
             external_memory_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
         wine_vk_normalize_handle_types_host(&external_memory_info->handleTypes);
     }
@@ -3855,7 +4015,7 @@ NTSTATUS wine_vkCreateImage(void *args)
 
     if ((external_memory_info = wine_vk_find_struct(&create_info_host, EXTERNAL_MEMORY_IMAGE_CREATE_INFO)))
     {
-        if (external_memory_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR)
+        if (external_memory_info->handleTypes & wine_vk_handle_over_fd_types)
             external_memory_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
         wine_vk_normalize_handle_types_host(&external_memory_info->handleTypes);
     }
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index 0946c3629dd..88a87dd4317 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -290,4 +290,11 @@ extern VkResult WINAPI __wine_create_vk_instance_with_callback(const VkInstanceC
 extern VkResult WINAPI __wine_create_vk_device_with_callback(VkPhysicalDevice phys_dev, const VkDeviceCreateInfo *create_info,
         const VkAllocationCallbacks *allocator, VkDevice *device, PFN_native_vkCreateDevice callback, void *context) DECLSPEC_HIDDEN;
 
+static inline void init_unicode_string( UNICODE_STRING *str, const WCHAR *data )
+{
+    str->Length = lstrlenW(data) * sizeof(WCHAR);
+    str->MaximumLength = str->Length + sizeof(WCHAR);
+    str->Buffer = (WCHAR *)data;
+}
+
 #endif /* __WINE_VULKAN_PRIVATE_H */
diff --git a/include/ddk/wdm.h b/include/ddk/wdm.h
index b798d339561..a5aec6e27e5 100644
--- a/include/ddk/wdm.h
+++ b/include/ddk/wdm.h
@@ -1818,6 +1818,7 @@ NTSTATUS  WINAPI ObRegisterCallbacks(POB_CALLBACK_REGISTRATION, void**);
 NTSTATUS  WINAPI ObReferenceObjectByHandle(HANDLE,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,PVOID*,POBJECT_HANDLE_INFORMATION);
 NTSTATUS  WINAPI ObReferenceObjectByName(UNICODE_STRING*,ULONG,ACCESS_STATE*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,void*,void**);
 NTSTATUS  WINAPI ObReferenceObjectByPointer(void*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE);
+NTSTATUS  WINAPI ObOpenObjectByPointer(void *,ULONG,ACCESS_STATE*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,HANDLE*);
 void      WINAPI ObUnRegisterCallbacks(void*);
 
 NTSTATUS  WINAPI PoCallDriver(DEVICE_OBJECT*,IRP*);
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 75f3775bc2b..d72cb9cccc9 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -200,6 +200,7 @@ AddService=Winmgmt,0,WinmgmtService
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [DefaultInstall.NT.Services]
 AddService=BITS,0,BITSService
@@ -219,6 +220,7 @@ AddService=Winmgmt,0,WinmgmtService
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [DefaultInstall.ntamd64.Services]
 AddService=BITS,0,BITSService
@@ -238,6 +240,7 @@ AddService=Winmgmt,0,WinmgmtService
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [DefaultInstall.ntarm64.Services]
 AddService=BITS,0,BITSService
@@ -257,6 +260,7 @@ AddService=Winmgmt,0,WinmgmtService
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [Strings]
 MciExtStr="Software\Microsoft\Windows NT\CurrentVersion\MCI Extensions"
@@ -5502,6 +5506,15 @@ LoadOrderGroup="System Bus Extender"
 [NsiProxyServiceKeys]
 HKR,,"Tag",0x10001,1
 
+[SharedGpuResourcesService]
+Description="Shared GPU Resources Manager Service"
+DisplayName="Shared GPU Resources Manager"
+ServiceBinary="%12%\sharedgpures.sys"
+ServiceType=1
+StartType=2
+ErrorControl=1
+LoadOrderGroup="System Bus Extender"
+
 [RpcSsService]
 Description="RPC service"
 DisplayName="Remote Procedure Call (RPC)"
From 070f3c9f753dcc08dd3935de653678775eb57b4d Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Wed, 13 Oct 2021 13:34:49 +0200
Subject: [PATCH] sharedgpures: Add support for arbitrary metadata.

---
 dlls/sharedgpures.sys/shared_resource.c | 57 +++++++++++++++++++++++--
 1 file changed, 53 insertions(+), 4 deletions(-)

diff --git a/dlls/sharedgpures.sys/shared_resource.c b/dlls/sharedgpures.sys/shared_resource.c
index 0ff16385b4f..caa5b4227d0 100644
--- a/dlls/sharedgpures.sys/shared_resource.c
+++ b/dlls/sharedgpures.sys/shared_resource.c
@@ -23,6 +23,8 @@ struct shared_resource
     unsigned int ref_count;
     void *unix_resource;
     WCHAR *name;
+    void *metadata;
+    SIZE_T metadata_size;
 };
 
 static struct shared_resource *resource_pool;
@@ -246,6 +248,33 @@ static NTSTATUS shared_resource_get_unix_resource(struct shared_resource *res, v
     return STATUS_SUCCESS;
 }
 
+#define IOCTL_SHARED_GPU_RESOURCE_SET_METADATA           CTL_CODE(FILE_DEVICE_VIDEO, 4, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+static NTSTATUS shared_resource_set_metadata(struct shared_resource *res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    res->metadata = ExAllocatePoolWithTag(NonPagedPool, insize, 0);
+    memcpy(res->metadata, buff, insize);
+    res->metadata_size = insize;
+
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_METADATA           CTL_CODE(FILE_DEVICE_VIDEO, 5, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static NTSTATUS shared_resource_get_metadata(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    if (!res->metadata)
+        return STATUS_NOT_FOUND;
+
+    if (res->metadata_size > outsize)
+        return STATUS_BUFFER_TOO_SMALL;
+
+    memcpy(buff, res->metadata, res->metadata_size);
+    iosb->Information = res->metadata_size;
+    return STATUS_SUCCESS;
+}
+
 static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
 {
     irp->IoStatus.u.Status = STATUS_SUCCESS;
@@ -263,11 +292,19 @@ static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
     if (res)
     {
         res->ref_count--;
-        if (!res->ref_count && res->unix_resource)
+        if (!res->ref_count)
         {
-            /* TODO: see if its possible to destroy the object here (unlink?) */
-            ObDereferenceObject(res->unix_resource);
-            res->unix_resource = NULL;
+            if (res->unix_resource)
+            {
+                /* TODO: see if its possible to destroy the object here (unlink?) */
+                ObDereferenceObject(res->unix_resource);
+                res->unix_resource = NULL;
+            }
+            if (res->metadata)
+            {
+                ExFreePoolWithTag(res->metadata, 0);
+                res->metadata = NULL;
+            }
         }
     }
 
@@ -313,6 +350,18 @@ static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
                                       stack->Parameters.DeviceIoControl.OutputBufferLength,
                                       &irp->IoStatus );
             break;
+        case IOCTL_SHARED_GPU_RESOURCE_SET_METADATA:
+            status = shared_resource_set_metadata( *res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_METADATA:
+            status = shared_resource_get_metadata( *res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
     default:
         FIXME( "ioctl %x not supported\n", stack->Parameters.DeviceIoControl.IoControlCode );
         status = STATUS_NOT_SUPPORTED;
