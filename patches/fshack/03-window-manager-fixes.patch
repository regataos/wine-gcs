From a412390af147ece7fb1fb6c381fc6822cbc44915 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 30 Jan 2020 14:44:00 -0600
Subject: [PATCH] HACK: user32: Don't resize new windows to fit the display.

---
 dlls/user32/win.c    | 4 ++--
 dlls/user32/winpos.c | 2 --
 2 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 4f1f70d9802..0783daee5d9 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -1739,8 +1739,8 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
     if ((cs->style & WS_THICKFRAME) || !(cs->style & (WS_POPUP | WS_CHILD)))
     {
         MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
-        cx = max( min( cx, info.ptMaxTrackSize.x ), info.ptMinTrackSize.x );
-        cy = max( min( cy, info.ptMaxTrackSize.y ), info.ptMinTrackSize.y );
+        cx = max( cx, info.ptMinTrackSize.x );
+        cy = max( cy, info.ptMinTrackSize.y );
     }
 
     if (cx < 0) cx = 0;
diff --git a/dlls/user32/winpos.c b/dlls/user32/winpos.c
index ff23206b395..e03f1149914 100644
--- a/dlls/user32/winpos.c
+++ b/dlls/user32/winpos.c
@@ -1663,8 +1663,6 @@ LONG WINPOS_HandleWindowPosChanging( HWND hwnd, WINDOWPOS *winpos )
     if ((style & WS_THICKFRAME) || ((style & (WS_POPUP | WS_CHILD)) == 0))
     {
 	MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
-        winpos->cx = min( winpos->cx, info.ptMaxTrackSize.x );
-        winpos->cy = min( winpos->cy, info.ptMaxTrackSize.y );
 	if (!(style & WS_MINIMIZE))
 	{
             winpos->cx = max( winpos->cx, info.ptMinTrackSize.x );
From 728e589b581520fc430bcdbaca9ee618a2c873df Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 26 Feb 2021 08:59:56 -0600
Subject: [PATCH] HACK: winex11.drv: Add WM detection code.

---
 dlls/winex11.drv/window.c      | 78 ++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/x11drv.h      |  6 +++
 dlls/winex11.drv/x11drv_main.c |  4 ++
 include/wine/gdi_driver.h      | 18 ++++++++
 4 files changed, 106 insertions(+)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index f76e020323a..99d8fd3871e 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -106,6 +106,82 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION win_data_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 
+static int detect_wm(Display *dpy)
+{
+    Display *display = dpy ? dpy : thread_init_display(); /* DefaultRootWindow is a macro... */
+    Window root = DefaultRootWindow(display), *wm_check;
+    Atom type;
+    int format;
+    unsigned long count, remaining;
+    char *wm_name;
+
+    static int cached = -1;
+
+    if(cached < 0){
+
+        if (XGetWindowProperty( display, root, x11drv_atom(_NET_SUPPORTING_WM_CHECK), 0,
+                                 sizeof(*wm_check)/sizeof(CARD32), False, x11drv_atom(WINDOW),
+                                 &type, &format, &count, &remaining, (unsigned char **)&wm_check ) == Success){
+            if (type == x11drv_atom(WINDOW)){
+                if(XGetWindowProperty( display, *wm_check, x11drv_atom(_NET_WM_NAME), 0,
+                            256/sizeof(CARD32), False, x11drv_atom(UTF8_STRING),
+                            &type, &format, &count, &remaining, (unsigned char **)&wm_name) == Success &&
+                        type == x11drv_atom(UTF8_STRING)){
+                    /* noop */
+                }else if(XGetWindowProperty( display, *wm_check, x11drv_atom(WM_NAME), 0,
+                            256/sizeof(CARD32), False, x11drv_atom(STRING),
+                            &type, &format, &count, &remaining, (unsigned char **)&wm_name) == Success &&
+                        type == x11drv_atom(STRING)){
+                    /* noop */
+                }else
+                    wm_name = NULL;
+
+                if(wm_name){
+                    TRACE("Got WM name %s\n", wm_name);
+
+                    if((strcmp(wm_name, "GNOME Shell") == 0) ||
+                            (strcmp(wm_name, "Mutter") == 0))
+                        cached = WINE_WM_X11_MUTTER;
+                    else if(strcmp(wm_name, "steamcompmgr") == 0)
+                        cached = WINE_WM_X11_STEAMCOMPMGR;
+                    else if(strcmp(wm_name, "KWin") == 0)
+                        cached = WINE_WM_X11_KDE;
+                    else
+                        cached = WINE_WM_UNKNOWN;
+
+                    XFree(wm_name);
+                }else{
+                    TRACE("WM did not set _NET_WM_NAME or WM_NAME\n");
+                    cached = WINE_WM_UNKNOWN;
+                }
+            }else
+                cached = WINE_WM_UNKNOWN;
+
+            XFree(wm_check);
+        }else
+            cached = WINE_WM_UNKNOWN;
+
+        __wine_set_window_manager(cached);
+    }
+
+    return cached;
+}
+
+BOOL wm_is_mutter(Display *display)
+{
+    return detect_wm(display) == WINE_WM_X11_MUTTER;
+}
+
+BOOL wm_is_kde(Display *display)
+{
+    return detect_wm(display) == WINE_WM_X11_KDE;
+}
+
+BOOL wm_is_steamcompmgr(Display *display)
+{
+    return detect_wm(display) == WINE_WM_X11_STEAMCOMPMGR;
+}
+
 /***********************************************************************
  * http://standards.freedesktop.org/startup-notification-spec
  */
@@ -1843,6 +1919,8 @@ BOOL CDECL X11DRV_CreateDesktopWindow( HWND hwnd )
 {
     unsigned int width, height;
 
+    detect_wm( gdi_display );
+
     /* retrieve the real size of the desktop */
     SERVER_START_REQ( get_window_rectangles )
     {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 4e6dcceb441..91cb02b902e 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -462,6 +462,7 @@ enum x11drv_atoms
     XATOM_TEXT,
     XATOM_TIMESTAMP,
     XATOM_UTF8_STRING,
+    XATOM_STRING,
     XATOM_RAW_ASCENT,
     XATOM_RAW_DESCENT,
     XATOM_RAW_CAP_HEIGHT,
@@ -469,6 +470,7 @@ enum x11drv_atoms
     XATOM_Rel_Y,
     XATOM_WM_PROTOCOLS,
     XATOM_WM_DELETE_WINDOW,
+    XATOM_WM_NAME,
     XATOM_WM_STATE,
     XATOM_WM_TAKE_FOCUS,
     XATOM_DndProtocol,
@@ -478,6 +480,7 @@ enum x11drv_atoms
     XATOM__NET_STARTUP_INFO_BEGIN,
     XATOM__NET_STARTUP_INFO,
     XATOM__NET_SUPPORTED,
+    XATOM__NET_SUPPORTING_WM_CHECK,
     XATOM__NET_SYSTEM_TRAY_OPCODE,
     XATOM__NET_SYSTEM_TRAY_S0,
     XATOM__NET_SYSTEM_TRAY_VISUAL,
@@ -528,6 +531,7 @@ enum x11drv_atoms
     XATOM_WCF_SYLK,
     XATOM_WCF_TIFF,
     XATOM_WCF_WAVE,
+    XATOM_WINDOW,
     XATOM_image_bmp,
     XATOM_image_gif,
     XATOM_image_jpeg,
@@ -654,6 +658,8 @@ extern void change_systray_owner( Display *display, Window systray_window ) DECL
 extern void update_systray_balloon_position(void) DECLSPEC_HIDDEN;
 extern HWND create_foreign_window( Display *display, Window window ) DECLSPEC_HIDDEN;
 extern BOOL update_clipboard( HWND hwnd ) DECLSPEC_HIDDEN;
+extern BOOL wm_is_mutter(Display *) DECLSPEC_HIDDEN;
+extern BOOL wm_is_steamcompmgr(Display *) DECLSPEC_HIDDEN;
 
 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 6bf4a0a4211..c979f968877 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -146,6 +146,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "TEXT",
     "TIMESTAMP",
     "UTF8_STRING",
+    "STRING",
     "RAW_ASCENT",
     "RAW_DESCENT",
     "RAW_CAP_HEIGHT",
@@ -153,6 +154,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "Rel Y",
     "WM_PROTOCOLS",
     "WM_DELETE_WINDOW",
+    "WM_NAME",
     "WM_STATE",
     "WM_TAKE_FOCUS",
     "DndProtocol",
@@ -162,6 +164,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "_NET_STARTUP_INFO_BEGIN",
     "_NET_STARTUP_INFO",
     "_NET_SUPPORTED",
+    "_NET_SUPPORTING_WM_CHECK",
     "_NET_SYSTEM_TRAY_OPCODE",
     "_NET_SYSTEM_TRAY_S0",
     "_NET_SYSTEM_TRAY_VISUAL",
@@ -212,6 +215,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "WCF_SYLK",
     "WCF_TIFF",
     "WCF_WAVE",
+    "WINDOW",
     "image/bmp",
     "image/gif",
     "image/jpeg",
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index 567a6c21608..7e0135430e1 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -349,4 +349,22 @@ extern void CDECL __wine_set_display_driver( struct user_driver_funcs *funcs, UI
 extern struct opengl_funcs * CDECL __wine_get_wgl_driver( HDC hdc, UINT version );
 extern const struct vulkan_funcs * CDECL __wine_get_vulkan_driver( UINT version );
 
+/* HACK: We use some WM specific hacks in user32 and we need the user
+ * driver to export that information. */
+
+#define WINE_WM_UNKNOWN          0
+#define WINE_WM_X11_MUTTER       1
+#define WINE_WM_X11_STEAMCOMPMGR 2
+#define WINE_WM_X11_KDE          3
+
+static inline LONG_PTR __wine_get_window_manager(void)
+{
+    return (LONG_PTR)GetPropA(GetDesktopWindow(), "__wine_window_manager");
+}
+
+static inline void __wine_set_window_manager(LONG_PTR window_manager)
+{
+    SetPropA(GetDesktopWindow(), "__wine_window_manager", (HANDLE)window_manager);
+}
+
 #endif /* __WINE_WINE_GDI_DRIVER_H */

From 376cf4fd52c091b39b1373c4fc42d56b0c755512 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 12 Mar 2020 15:53:07 +0100
Subject: [PATCH] HACK: gamescope: user32: On steamcompmgr, don't limit window
 size to screen size

---
 dlls/user32/win.c    | 10 ++++++++++
 dlls/user32/winpos.c | 10 ++++++++++
 2 files changed, 20 insertions(+)

diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 0783daee5d9..4618c73d95f 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -1739,6 +1739,16 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
     if ((cs->style & WS_THICKFRAME) || !(cs->style & (WS_POPUP | WS_CHILD)))
     {
         MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
+
+        /* HACK: This code changes the window's size to fit the display. However,
+         * some games (Bayonetta, Dragon's Dogma) will then have the incorrect
+         * render size. So just let windows be too big to fit the display. */
+        if (__wine_get_window_manager() != WINE_WM_X11_STEAMCOMPMGR)
+        {
+            cx = min( cx, info.ptMaxTrackSize.x );
+            cy = min( cy, info.ptMaxTrackSize.y );
+        }
+
         cx = max( cx, info.ptMinTrackSize.x );
         cy = max( cy, info.ptMinTrackSize.y );
     }
diff --git a/dlls/user32/winpos.c b/dlls/user32/winpos.c
index e03f1149914..c5ecffa561c 100644
--- a/dlls/user32/winpos.c
+++ b/dlls/user32/winpos.c
@@ -1663,6 +1663,16 @@ LONG WINPOS_HandleWindowPosChanging( HWND hwnd, WINDOWPOS *winpos )
     if ((style & WS_THICKFRAME) || ((style & (WS_POPUP | WS_CHILD)) == 0))
     {
 	MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
+
+        /* HACK: This code changes the window's size to fit the display. However,
+         * some games (Bayonetta, Dragon's Dogma) will then have the incorrect
+         * render size. So just let windows be too big to fit the display. */
+        if (__wine_get_window_manager() != WINE_WM_X11_STEAMCOMPMGR)
+        {
+            winpos->cx = min( winpos->cx, info.ptMaxTrackSize.x );
+            winpos->cy = min( winpos->cy, info.ptMaxTrackSize.y );
+        }
+
 	if (!(style & WS_MINIMIZE))
 	{
             winpos->cx = max( winpos->cx, info.ptMinTrackSize.x );
From 8e7dcb8367325d91cfa2b7d6bd5e4495cda71889 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 16 Mar 2020 19:52:52 +0100
Subject: [PATCH] HACK: gamescope: user32: Pretend that windows are undecorated
 with gamescope.

The original commit made all window have their client rect always match
their window rects. This was to make sure games always use the full
available window size, even when windowed, and end up with an optimal
rendering area.

Some games, such as Bayonetta or Dragon's Dogma: Dark Arisen, ask for an
optimal window size, but, when in windowed mode, the client rect is then
adjusted to add a title bar and borders. On Windows, the back buffer is
always the requested size, but the rendering is then scaled to match the
client rect. With Proton and gamescope, we want to avoid this suboptimal
scaling, and make sure both front and back buffer are optimally sized,
including when in windowed mode.

Then, we still need to keep adjustments on WS_POPUP / WS_EX_TOOLWINDOW
windows:

This styles usually translates into a single pixel border, and is used
for splash screens. Several of them do not expect their client rect to
be sized as the window rect and it causes a visible 1px white border on
the bottom and the right of the window.

WS_EX_TOOLWINDOW should be safe enough, as it means the window is not
supposed to be displayed in the taskbar or in the alt-tab menu, which is
unlikely for an actual game window. WS_POPUP otoh means that only a 1px
border is used, which should not make much of a difference with an
undecorated window (although it could cause suboptimal client rect
sizes, which we wanted to solve in the first place).

CW-Bug-Id: #17639
CW-Bug-Id: #20038
---
 dlls/user32/nonclient.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/user32/nonclient.c b/dlls/user32/nonclient.c
index b47616bb639..ff9f9b8e197 100644
--- a/dlls/user32/nonclient.c
+++ b/dlls/user32/nonclient.c
@@ -28,6 +28,7 @@
 #include "user_private.h"
 #include "controls.h"
 #include "wine/debug.h"
+#include "wine/gdi_driver.h"

 WINE_DEFAULT_DEBUG_CHANNEL(nonclient);

@@ -60,6 +61,9 @@ static void adjust_window_rect( RECT *rect, DWORD style, BOOL menu, DWORD exStyl
 {
     int adjust = 0;

+    if (__wine_get_window_manager() == WINE_WM_X11_STEAMCOMPMGR && !((style & WS_POPUP) && (exStyle & WS_EX_TOOLWINDOW)))
+        return;
+
     if ((exStyle & (WS_EX_STATICEDGE|WS_EX_DLGMODALFRAME)) == WS_EX_STATICEDGE)
         adjust = 1; /* for the outer frame always present */
     else if ((exStyle & WS_EX_DLGMODALFRAME) || (style & (WS_THICKFRAME|WS_DLGFRAME)))
@@ -357,6 +361,9 @@ LRESULT NC_HandleNCCalcSize( HWND hwnd, WPARAM wparam, RECT *winRect )
     if (winRect == NULL)
         return 0;

+    if (__wine_get_window_manager() == WINE_WM_X11_STEAMCOMPMGR && !((style & WS_POPUP) && (exStyle & WS_EX_TOOLWINDOW)))
+        return 0;
+
     if (!(style & WS_MINIMIZE))
     {

From 132d293262d95a5ab8810ebbda13028fac2e9f78 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 May 2021 17:41:43 +0200
Subject: [PATCH] HACK: gamescope: winex11.drv: Disable gamescope hacks for
 Street Fighter V.

CW-Bug-Id: #18903
---
 dlls/winex11.drv/window.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 99d8fd3871e..01b12f96e03 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -114,6 +114,7 @@ static int detect_wm(Display *dpy)
     int format;
     unsigned long count, remaining;
     char *wm_name;
+    char const *sgi = getenv("SteamGameId");

     static int cached = -1;

@@ -161,6 +162,11 @@ static int detect_wm(Display *dpy)
         }else
             cached = WINE_WM_UNKNOWN;

+        /* Street Fighter V expects a certain sequence of window resizes
+           or gets stuck on startup. The AdjustWindowRect / WM_NCCALCSIZE
+           hacks confuse it completely, so let's disable them */
+        if (sgi && !strcmp(sgi, "310950")) cached = WINE_WM_UNKNOWN;
+
         __wine_set_window_manager(cached);
     }

From 7563c241f385299b4639c3b939558c2ba430886e Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 18 Sep 2018 14:48:58 -0500
Subject: [PATCH] winex11.drv: Allow the application to change window size and
 states during PropertyNotify.

On focus loss, fullscreened DDLC changes to a 1x1 pixel window and
minimizes. On restore, it un-minimizes and changes back to fullscreen
size. However, this restoring happens during the PropertyNotify handler,
which means we didn't update size or the NET_WM_STATEs.
---
 dlls/winex11.drv/window.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 01b12f96e03..294d84bfccc 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2615,7 +2615,7 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
     }

     /* don't change position if we are about to minimize or maximize a managed window */
-    if (!event_type &&
+    if ((!event_type || event_type == PropertyNotify) &&
         !(data->managed && (swp_flags & SWP_STATECHANGED) && (new_style & (WS_MINIMIZE|WS_MAXIMIZE))))
         sync_window_position( data, swp_flags, &old_window_rect, &old_whole_rect, &old_client_rect );

@@ -2649,7 +2649,7 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
         else
         {
             if (swp_flags & (SWP_FRAMECHANGED|SWP_STATECHANGED)) set_wm_hints( data );
-            if (!event_type) update_net_wm_states( data );
+            if (!event_type || event_type == PropertyNotify) update_net_wm_states( data );
         }
     }

From 32821e17a97f4e0afb703eaf17280cadb8030a16 Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Wed, 17 Oct 2018 19:55:27 +0300
Subject: [PATCH] winex11.drv: Ignore clip_reset when trying to clip the mouse
 after the desktop has been resized.

This fixes the mouse clipping when the desktop is resized multiple times in a row.
---
 dlls/winex11.drv/mouse.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index d02163cbaa8..d2ff071a9f2 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -579,9 +579,10 @@ BOOL clip_fullscreen_window( HWND hwnd, BOOL reset )
     release_win_data( data );
     if (!fullscreen) return FALSE;
     if (!(thread_data = x11drv_thread_data())) return FALSE;
-    if (GetTickCount() - thread_data->clip_reset < 1000) return FALSE;
-    if (!reset && clipping_cursor && thread_data->clip_hwnd) return FALSE;  /* already clipping */
-
+    if (!reset) {
+        if (GetTickCount() - thread_data->clip_reset < 1000) return FALSE;
+        if (!reset && clipping_cursor && thread_data->clip_hwnd) return FALSE;  /* already clipping */
+    }
     monitor = MonitorFromWindow( hwnd, MONITOR_DEFAULTTONEAREST );
     if (!monitor) return FALSE;
     monitor_info.cbSize = sizeof(monitor_info);
From 36535de250f26fbfd46c6383179e4c9bfe2ce956 Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Sat, 20 Oct 2018 18:07:12 +0300
Subject: [PATCH] winex11.drv: Enable fullscreen clipping even if not already
 clipping.

---
 dlls/winex11.drv/mouse.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index d2ff071a9f2..9635d264e14 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1571,12 +1571,12 @@ BOOL CDECL X11DRV_ClipCursor( LPCRECT clip )
         {
             if (grab_clipping_window( clip )) return TRUE;
         }
-        else /* if currently clipping, check if we should switch to fullscreen clipping */
+        else /* check if we should switch to fullscreen clipping */
         {
             struct x11drv_thread_data *data = x11drv_thread_data();
-            if (data && data->clip_hwnd)
+            if (data)
             {
-                if (EqualRect( clip, &clip_rect ) || clip_fullscreen_window( foreground, TRUE ))
+                if ((data->clip_hwnd && EqualRect( clip, &clip_rect ) && !EqualRect(&clip_rect, &virtual_rect)) || clip_fullscreen_window( foreground, TRUE ))
                     return TRUE;
             }
         }
From 3ebc519f891b4fe027e1161bebdcfd4eeed7c079 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 11 Jan 2019 11:31:13 -0600
Subject: [PATCH] winex11.drv: Don't show border if WS_CAPTION is unset.

Into the Breach wants a borderless window with WS_THICKFRAME. If we
leave the BORDER and RESIZEH styles on, then we get a window with a
border and a caption on Linux.
---
 dlls/winex11.drv/window.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 294d84bfccc..319a28d6fa3 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -414,7 +414,10 @@ static unsigned long get_mwm_decorations( struct x11drv_win_data *data,
         if (style & WS_MAXIMIZEBOX) ret |= MWM_DECOR_MAXIMIZE;
     }
     if (ex_style & WS_EX_DLGMODALFRAME) ret |= MWM_DECOR_BORDER;
-    else if (style & WS_THICKFRAME) ret |= MWM_DECOR_BORDER | MWM_DECOR_RESIZEH;
+    else if (style & WS_THICKFRAME){
+        if((style & WS_CAPTION) == WS_CAPTION)
+             ret |= MWM_DECOR_BORDER | MWM_DECOR_RESIZEH;
+    }
     else if ((style & (WS_DLGFRAME|WS_BORDER)) == WS_DLGFRAME) ret |= MWM_DECOR_BORDER;
     return ret;
 }
From 24d7f2bda1e98905206476fa3664ea8fa7bd7dd1 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 11 Jan 2019 11:34:03 -0600
Subject: [PATCH] winex11.drv: Ignore ConfigureNotify messages if there is a
 FULLSCREEN WM state pending.

Into the Breach goes fullscreen by first maximizing, then setting the
window to fullscreen in a separate call. Mutter processes the maximize
request _after_ Wine has sent the fullscreen request. As a result, we
get a ConfigureNotify for the size of the workspace when we expect the
window to be fullscreened. We then notify ITB that it is no longer
fullscreen, which begins the process over again, causing an infinite
loop.

This fixes that by setting a flag if we have a fullscreen request
pending and ignoring ConfigureNotify requests if it is set. We unset it
when we receive a _NET_WM_STATE PropertyNotify event that contains the
FULLSCREEN flag.
---
 dlls/winex11.drv/event.c  | 35 +++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/window.c |  3 +++
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 39 insertions(+)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index b7f5614f222..42c66f911ce 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -1129,6 +1129,12 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
                event->serial, data->configure_serial );
         goto done;
     }
+    if (data->pending_fullscreen)
+    {
+        TRACE( "win %p/%lx event %d,%d,%dx%d pending_fullscreen is pending, so ignoring\n",
+               hwnd, data->whole_window, event->x, event->y, event->width, event->height );
+        goto done;
+    }

     /* Get geometry */

@@ -1362,15 +1368,44 @@ static void handle_wm_state_notify( HWND hwnd, XPropertyEvent *event, BOOL updat
 }


+static void handle__net_wm_state_notify( HWND hwnd, XPropertyEvent *event )
+{
+    struct x11drv_win_data *data = get_win_data( hwnd );
+
+    if(data->pending_fullscreen)
+    {
+        read_net_wm_states( event->display, data );
+        if(data->net_wm_state & (1 << NET_WM_STATE_FULLSCREEN)){
+            data->pending_fullscreen = FALSE;
+            TRACE("PropertyNotify _NET_WM_STATE, now 0x%x, pending_fullscreen no longer pending.\n",
+                    data->net_wm_state);
+        }else
+            TRACE("PropertyNotify _NET_WM_STATE, now 0x%x, pending_fullscreen still pending.\n",
+                    data->net_wm_state);
+    }
+
+    release_win_data( data );
+}
+
+
 /***********************************************************************
  *           X11DRV_PropertyNotify
  */
 static BOOL X11DRV_PropertyNotify( HWND hwnd, XEvent *xev )
 {
     XPropertyEvent *event = &xev->xproperty;
+    char *name;

     if (!hwnd) return FALSE;
+
+    name = XGetAtomName(event->display, event->atom);
+    if(name){
+        TRACE("win %p PropertyNotify atom: %s, state: 0x%x\n", hwnd, name, event->state);
+        XFree(name);
+    }
+
     if (event->atom == x11drv_atom(WM_STATE)) handle_wm_state_notify( hwnd, event, TRUE );
+    else if (event->atom == x11drv_atom(_NET_WM_STATE)) handle__net_wm_state_notify( hwnd, event );
     return TRUE;
 }

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 319a28d6fa3..1d42801291c 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1260,6 +1260,7 @@ static void unmap_window( HWND hwnd )

         data->mapped = FALSE;
         data->net_wm_state = 0;
+        data->pending_fullscreen = FALSE;
     }
     release_win_data( data );
 }
@@ -1276,6 +1277,7 @@ void make_window_embedded( struct x11drv_win_data *data )
         if (!data->managed) XUnmapWindow( data->display, data->whole_window );
         else XWithdrawWindow( data->display, data->whole_window, data->vis.screen );
         data->net_wm_state = 0;
+        data->pending_fullscreen = FALSE;
     }
     data->embedded = TRUE;
     data->managed = TRUE;
@@ -1759,6 +1761,7 @@ static void destroy_whole_window( struct x11drv_win_data *data, BOOL already_des
     data->whole_colormap = 0;
     data->wm_state = WithdrawnState;
     data->net_wm_state = 0;
+    data->pending_fullscreen = FALSE;
     data->mapped = FALSE;
     if (data->xic)
     {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 91cb02b902e..9767fdcf681 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -621,6 +621,7 @@ struct x11drv_win_data
     BOOL        use_alpha : 1;  /* does window use an alpha channel? */
     BOOL        skip_taskbar : 1; /* does window should be deleted from taskbar */
     BOOL        add_taskbar : 1; /* does window should be added to taskbar regardless of style */
+    BOOL        pending_fullscreen : 1;
     int         wm_state;       /* current value of the WM_STATE property */
     DWORD       net_wm_state;   /* bit mask of active x11drv_net_wm_state values */
     Window      embedder;       /* window id of embedder */
From c00373fafc69068a300e44a188b4a139ab274abb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 21 Jan 2020 21:05:05 +0100
Subject: [PATCH] winex11.drv: Ignore ClipCursor if desktop window is
 foreground.

---
 dlls/winex11.drv/mouse.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 9635d264e14..321b631d6ca 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1556,6 +1556,13 @@ BOOL CDECL X11DRV_ClipCursor( LPCRECT clip )
         HWND foreground = GetForegroundWindow();
         DWORD tid, pid;

+        if (foreground == GetDesktopWindow())
+        {
+            WARN( "desktop is foreground, ignoring ClipCursor\n" );
+            ungrab_clipping_window();
+            return TRUE;
+        }
+
         /* forward request to the foreground window if it's in a different thread */
         tid = GetWindowThreadProcessId( foreground, &pid );
         if (tid && tid != GetCurrentThreadId() && pid == GetCurrentProcessId())
From b036845239c5b01f3715ef0d3b24e5044137836c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 26 Jun 2019 18:42:37 +0200
Subject: [PATCH] HACK: mutter: winex11.drv: Workaround mutter issue #649.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When decorations are modified too quickly, mutter loses tracks of the
reparenting requests and does not gives focus back to the window.

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
---
 dlls/winex11.drv/window.c | 43 ++++++++++++++++++++++++++++++++++++++-
 dlls/winex11.drv/x11drv.h |  4 ++++
 2 files changed, 46 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 1d42801291c..1b292df11fe 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -48,7 +48,6 @@
 #include "x11drv.h"
 #include "wine/debug.h"
 #include "wine/server.h"
-#include "mwm.h"

 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);

@@ -814,6 +813,13 @@ static void set_size_hints( struct x11drv_win_data *data, DWORD style )
     XFree( size_hints );
 }

+static Bool is_unmap_notify( Display *display, XEvent *event, XPointer arg )
+{
+    struct x11drv_win_data *data = (struct x11drv_win_data *)arg;
+    return event->xany.serial >= data->unmapnotify_serial &&
+           event->xany.window == data->whole_window &&
+           event->type == UnmapNotify;
+}

 /***********************************************************************
  *              set_mwm_hints
@@ -821,6 +827,7 @@ static void set_size_hints( struct x11drv_win_data *data, DWORD style )
 static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_style )
 {
     MwmHints mwm_hints;
+    int enable_mutter_workaround, mapped;

     if (data->hwnd == GetDesktopWindow())
     {
@@ -848,12 +855,46 @@ static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_s
     TRACE( "%p setting mwm hints to %lx,%lx (style %x exstyle %x)\n",
            data->hwnd, mwm_hints.decorations, mwm_hints.functions, style, ex_style );

+    enable_mutter_workaround = wm_is_mutter(data->display) && GetFocus() == data->hwnd &&
+                               !!data->prev_hints.decorations != !!mwm_hints.decorations &&
+                               root_window == DefaultRootWindow(data->display);
+
+    /* workaround for mutter gitlab bug #649, we cannot trust the
+     * data->mapped flag as mapping is asynchronous.
+     */
+    if (enable_mutter_workaround)
+    {
+        XWindowAttributes attr;
+
+        mapped = data->mapped;
+        if (XGetWindowAttributes( data->display, data->whole_window, &attr ))
+            mapped = (attr.map_state != IsUnmapped);
+    }
+
     mwm_hints.flags = MWM_HINTS_FUNCTIONS | MWM_HINTS_DECORATIONS;
     mwm_hints.input_mode = 0;
     mwm_hints.status = 0;
+    data->unmapnotify_serial = NextRequest( data->display );
     XChangeProperty( data->display, data->whole_window, x11drv_atom(_MOTIF_WM_HINTS),
                      x11drv_atom(_MOTIF_WM_HINTS), 32, PropModeReplace,
                      (unsigned char*)&mwm_hints, sizeof(mwm_hints)/sizeof(long) );
+
+    if (enable_mutter_workaround)
+    {
+        XEvent event;
+
+        /* workaround for mutter gitlab bug #649, wait for the map notify
+         * event each time the decorations are modified before modifying
+         * them again.
+         */
+        if (mapped)
+        {
+            TRACE("workaround mutter bug #649, waiting for UnmapNotify\n");
+            XPeekIfEvent( data->display, &event, is_unmap_notify, (XPointer)data );
+        }
+    }
+
+    data->prev_hints = mwm_hints;
 }


diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 9767fdcf681..bd8492c57b7 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -62,6 +62,8 @@ typedef int Status;
 #include "wine/gdi_driver.h"
 #include "wine/list.h"

+#include "mwm.h"
+
 #define MAX_DASHLEN 16

 #define WINE_XDND_VERSION 5
@@ -625,12 +627,14 @@ struct x11drv_win_data
     int         wm_state;       /* current value of the WM_STATE property */
     DWORD       net_wm_state;   /* bit mask of active x11drv_net_wm_state values */
     Window      embedder;       /* window id of embedder */
+    unsigned long unmapnotify_serial; /* serial number of last UnmapNotify event */
     unsigned long configure_serial; /* serial number of last configure request */
     struct window_surface *surface;
     Pixmap         icon_pixmap;
     Pixmap         icon_mask;
     unsigned long *icon_bits;
     unsigned int   icon_size;
+    MwmHints prev_hints;
 };

 extern struct x11drv_win_data *get_win_data( HWND hwnd ) DECLSPEC_HIDDEN;
From fd82e3a50b586a6c1d05246b3ceb86cb00b59d9e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 24 Jul 2019 11:34:15 +0200
Subject: [PATCH] HACK: mutter: winex11.drv: Workaround mutter issue #676.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Changing decorations of a fullscreen and unredirected window breaks
compositing. So, we now ignore any decoration changes while window is
bypassing the compositor.

Decoration state will be restored as soon as the window changes its
state again. The windows are only bypassing compositor if they are also
fullscreen, so this should not have any visible side effect.

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
---
 dlls/winex11.drv/event.c       | 13 +++++++++++++
 dlls/winex11.drv/window.c      | 29 ++++++++++++++++++++++++++++-
 dlls/winex11.drv/x11drv.h      |  3 +++
 dlls/winex11.drv/x11drv_main.c |  1 +
 4 files changed, 45 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 42c66f911ce..f29e1bd7d1f 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -1404,6 +1404,19 @@ static BOOL X11DRV_PropertyNotify( HWND hwnd, XEvent *xev )
         XFree(name);
     }

+    if (event->atom == x11drv_atom(_NET_WM_BYPASS_COMPOSITOR))
+    {
+        struct x11drv_win_data *data = get_win_data( hwnd );
+        if (!data) return TRUE;
+
+        /* workaround for mutter gitlab bug #676, changing decorations of a
+         * fullscreen and unredirected window freezes the compositing.
+         */
+        if (wm_is_mutter( data->display )) set_wm_hints( data );
+
+        release_win_data( data );
+    }
+
     if (event->atom == x11drv_atom(WM_STATE)) handle_wm_state_notify( hwnd, event, TRUE );
     else if (event->atom == x11drv_atom(_NET_WM_STATE)) handle__net_wm_state_notify( hwnd, event );
     return TRUE;
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 1b292df11fe..2c3a9c32bc6 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -829,6 +829,33 @@ static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_s
     MwmHints mwm_hints;
     int enable_mutter_workaround, mapped;

+    /* workaround for mutter gitlab bug #676, changing decorations of a
+     * fullscreen and unredirected window freezes the compositing.
+     * The window style will be updated again once the window has returned
+     * from fullscreen.
+     */
+    if (wm_is_mutter(data->display) && (data->net_wm_state & (1 << NET_WM_STATE_FULLSCREEN)))
+    {
+        Atom type;
+        int format;
+        unsigned long *property, net_wm_bypass_compositor = 0, count, remaining;
+
+        if (XGetWindowProperty( data->display, data->whole_window, x11drv_atom(_NET_WM_BYPASS_COMPOSITOR), 0,
+                                1, False, XA_CARDINAL, &type, &format, &count, &remaining,
+                                (unsigned char **)&property ) == Success &&
+            property)
+        {
+            net_wm_bypass_compositor = *property;
+            XFree(property);
+        }
+
+        if (net_wm_bypass_compositor)
+        {
+            TRACE("workaround mutter bug, ignoring decorations while compositor is bypassed\n");
+            return;
+        }
+    }
+
     if (data->hwnd == GetDesktopWindow())
     {
         if (is_desktop_fullscreen()) mwm_hints.decorations = 0;
@@ -1040,7 +1067,7 @@ static void make_owner_managed( HWND hwnd )
  *
  * Set all the window manager hints for a window.
  */
-static void set_wm_hints( struct x11drv_win_data *data )
+void set_wm_hints( struct x11drv_win_data *data )
 {
     DWORD style, ex_style;

diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index bd8492c57b7..86d44997f43 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -486,6 +486,7 @@ enum x11drv_atoms
     XATOM__NET_SYSTEM_TRAY_OPCODE,
     XATOM__NET_SYSTEM_TRAY_S0,
     XATOM__NET_SYSTEM_TRAY_VISUAL,
+    XATOM__NET_WM_BYPASS_COMPOSITOR,
     XATOM__NET_WM_ICON,
     XATOM__NET_WM_MOVERESIZE,
     XATOM__NET_WM_NAME,
@@ -666,6 +667,8 @@ extern BOOL update_clipboard( HWND hwnd ) DECLSPEC_HIDDEN;
 extern BOOL wm_is_mutter(Display *) DECLSPEC_HIDDEN;
 extern BOOL wm_is_steamcompmgr(Display *) DECLSPEC_HIDDEN;

+extern void set_wm_hints( struct x11drv_win_data *data ) DECLSPEC_HIDDEN;
+
 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
     int width = window_rect->right - window_rect->left;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index c979f968877..1e7c140641f 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -168,6 +168,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "_NET_SYSTEM_TRAY_OPCODE",
     "_NET_SYSTEM_TRAY_S0",
     "_NET_SYSTEM_TRAY_VISUAL",
+    "_NET_WM_BYPASS_COMPOSITOR",
     "_NET_WM_ICON",
     "_NET_WM_MOVERESIZE",
     "_NET_WM_NAME",
From 27dd29bb185d04018493cdd2a025ff4961121769 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 9 Dec 2019 20:28:20 +0100
Subject: [PATCH] HACK: mutter: winex11.drv: Add a bit of delay before
 restoring mouse grabs on FocusIn.

---
 dlls/winex11.drv/event.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index f29e1bd7d1f..77d2990f01e 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -821,6 +821,14 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     if (event->detail == NotifyPointer) return FALSE;
     if (hwnd == GetDesktopWindow()) return FALSE;

+    /* Focus was just restored but it can be right after super was
+     * pressed and gnome-shell needs a bit of time to respond and
+     * toggle the activity view. If we grab the cursor right away
+     * it will cancel it and super key will do nothing.
+     */
+    if (event->mode == NotifyUngrab && wm_is_mutter(event->display))
+        Sleep(100);
+
     /* ask the foreground window to re-apply the current ClipCursor rect */
     SendMessageW( GetForegroundWindow(), WM_X11DRV_CLIP_CURSOR_REQUEST, 0, 0 );

From 985434fc5279470782763af3da1b4afec57d7ce0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 21 Aug 2018 14:47:33 -0500
Subject: [PATCH] HACK: mutter: winex11.drv: Workaround mutter issue #273.

This would cause fullscreen windows to lose keyboard focus.
---
 dlls/winex11.drv/event.c  | 18 ++++++++++++++++++
 dlls/winex11.drv/window.c |  8 ++++++++
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 27 insertions(+)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 77d2990f01e..b59d4105557 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -870,9 +870,27 @@ static void focus_out( Display *display , HWND hwnd )
     Window focus_win;
     int revert;
     XIC xic;
+    struct x11drv_win_data *data;

     if (ximInComposeMode) return;

+    data = get_win_data(hwnd);
+    if(data){
+        ULONGLONG now = GetTickCount64();
+        if(data->take_focus_back > 0 &&
+                now >= data->take_focus_back &&
+                now - data->take_focus_back < 1000){
+            data->take_focus_back = 0;
+            TRACE("workaround mutter bug, taking focus back\n");
+            XSetInputFocus( data->display, data->whole_window, RevertToParent, CurrentTime);
+            release_win_data(data);
+            /* don't inform win32 client */
+            return;
+        }
+        data->take_focus_back = 0;
+        release_win_data(data);
+    }
+
     x11drv_thread_data()->last_focus = hwnd;
     if ((xic = X11DRV_get_ic( hwnd ))) XUnsetICFocus( xic );

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 2c3a9c32bc6..45a45a29f1a 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -921,6 +921,14 @@ static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_s
         }
     }

+    if (wm_is_mutter(data->display) && GetFocus() == data->hwnd &&
+            !!data->prev_hints.decorations != !!mwm_hints.decorations)
+    {
+        /* workaround for mutter gitlab bug #273 */
+        TRACE("workaround mutter bug, setting take_focus_back\n");
+        data->take_focus_back = GetTickCount64();
+    }
+
     data->prev_hints = mwm_hints;
 }

diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 86d44997f43..52990283ce7 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -625,6 +625,7 @@ struct x11drv_win_data
     BOOL        skip_taskbar : 1; /* does window should be deleted from taskbar */
     BOOL        add_taskbar : 1; /* does window should be added to taskbar regardless of style */
     BOOL        pending_fullscreen : 1;
+    ULONGLONG   take_focus_back;
     int         wm_state;       /* current value of the WM_STATE property */
     DWORD       net_wm_state;   /* bit mask of active x11drv_net_wm_state values */
     Window      embedder;       /* window id of embedder */
From d2c3166e776eb399cd6b9e94b6fc954591bebdc8 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 25 Sep 2020 12:58:52 +0300
Subject: [PATCH] HACK: mutter: winex11.drv: Avoid setting empty shape for
 window on mutter.

---
 dlls/winex11.drv/bitblt.c | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/bitblt.c b/dlls/winex11.drv/bitblt.c
index fad183b0b01..1254fff14bf 100644
--- a/dlls/winex11.drv/bitblt.c
+++ b/dlls/winex11.drv/bitblt.c
@@ -1736,8 +1736,21 @@ static void update_surface_region( struct x11drv_window_surface *surface )

     if ((data = X11DRV_GetRegionData( rgn, 0 )))
     {
-        XShapeCombineRectangles( gdi_display, surface->window, ShapeBounding, 0, 0,
-                                 (XRectangle *)data->Buffer, data->rdh.nCount, ShapeSet, YXBanded );
+        if (!data->rdh.nCount && wm_is_mutter(gdi_display))
+        {
+            XRectangle xrect;
+
+            xrect.x = xrect.y = -1;
+            xrect.width = 1;
+            xrect.height = 1;
+            XShapeCombineRectangles( gdi_display, surface->window, ShapeBounding, 0, 0,
+                                     &xrect, 1, ShapeSet, YXBanded );
+        }
+        else
+        {
+            XShapeCombineRectangles( gdi_display, surface->window, ShapeBounding, 0, 0,
+                                     (XRectangle *)data->Buffer, data->rdh.nCount, ShapeSet, YXBanded );
+        }
         HeapFree( GetProcessHeap(), 0, data );
     }

From 39000841d68b3d8401bd5602113fdc146fc1ee43 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Tue, 8 Jun 2021 16:01:54 +0300
Subject: [PATCH] winex11.drv: Send missed KEYUP events on KeymapNotify.

Full focus lost / focus gained events on the Windows side are not
feasible for X11's FocusIn/FocusOut events generated by keyboard grabs
(see XGrabKeyboard()) that are used for example for Atl+Tab handling.
Using them would degrade user's experience, especially with our full
screen hack, by causing the window to minimize or flash multiple times
depending on a game/window manager combo.

Because of that the programs may miss on some KEYUP events that happen
during the grab, and since there are no focus changes on the Windows
side the state doesn't get resynced.

This change attempts to improve user experience by syncing any missed
key release events that happened while the window haven't had focus on
the X11 side.

There's no syncing of key presses as those are more problematic because
of window manager quirks, e.g. on KDE it may end up syncing the Tab
press portion of Alt+Tab. Luckily missing key events for keys that were
pressed and not released while the WM had the keyboard grab is not
nearly as confusing as stuck keys.

For Warhammer: Chaosbane, theHunter: Call of the Wild, Far Cry Primal
and many other games that end up with stuck Alt after Alt+Tabbing.

CW-Bug-ID: #17046
CW-Bug-ID: #18904
---
 dlls/winex11.drv/event.c    |  2 ++
 dlls/winex11.drv/keyboard.c | 43 +++++++++++++++++++++++++++++++++++--
 dlls/winex11.drv/mouse.c    |  2 ++
 dlls/winex11.drv/x11drv.h   |  1 +
 4 files changed, 46 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index b59d4105557..271a70940f1 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -821,6 +821,8 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     if (event->detail == NotifyPointer) return FALSE;
     if (hwnd == GetDesktopWindow()) return FALSE;

+    x11drv_thread_data()->keymapnotify_hwnd = hwnd;
+
     /* Focus was just restored but it can be right after super was
      * pressed and gnome-shell needs a bit of time to respond and
      * toggle the activity view. If we grab the cursor right away
diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index d04d1db9102..720b4869544 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1209,11 +1209,19 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
     int i, j;
     BYTE keystate[256];
     WORD vkey;
+    DWORD flags;
+    KeyCode keycode;
+    HWND keymapnotify_hwnd;
     BOOL changed = FALSE;
     struct {
         WORD vkey;
+        WORD scan;
         WORD pressed;
     } keys[256];
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+
+    keymapnotify_hwnd = thread_data->keymapnotify_hwnd;
+    thread_data->keymapnotify_hwnd = NULL;

     if (!get_async_key_state( keystate )) return FALSE;

@@ -1228,11 +1236,17 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
     {
         for (j = 0; j < 8; j++)
         {
-            vkey = keyc2vkey[(i * 8) + j];
+            keycode = (i * 8) + j;
+            vkey = keyc2vkey[keycode];

             /* If multiple keys map to the same vkey, we want to report it as
              * pressed iff any of them are pressed. */
-            if (!keys[vkey & 0xff].vkey) keys[vkey & 0xff].vkey = vkey;
+            if (!keys[vkey & 0xff].vkey)
+            {
+                keys[vkey & 0xff].vkey = vkey;
+                keys[vkey & 0xff].scan = keyc2scan[keycode] & 0xff;
+            }
+
             if (event->xkeymap.key_vector[i] & (1<<j)) keys[vkey & 0xff].pressed = TRUE;
         }
     }
@@ -1244,6 +1258,31 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
             TRACE( "Adjusting state for vkey %#.2x. State before %#.2x\n",
                    keys[vkey].vkey, keystate[vkey]);

+            /* This KeymapNotify follows a FocusIn(mode=NotifyUngrab) event,
+             * which is caused by a keyboard grab being released.
+             * See XGrabKeyboard().
+             *
+             * We might have missed some key press/release events while the
+             * keyboard was grabbed, but keyboard grab doesn't generate focus
+             * lost / focus gained events on the Windows side, so the affected
+             * program is not aware that it needs to resync the keyboard state.
+             *
+             * This, for example, may cause Alt being stuck after using Alt+Tab.
+             *
+             * To work around that problem we sync any possible key releases.
+             *
+             * Syncing key presses is not feasible as window managers differ in
+             * event sequences, e.g. KDE performs two keyboard grabs for
+             * Alt+Tab, which would sync the Tab press.
+             */
+            if (keymapnotify_hwnd && !keys[vkey].pressed)
+            {
+                TRACE( "Sending KEYUP for a modifier %#.2x\n", vkey);
+                flags = KEYEVENTF_KEYUP;
+                if (keys[vkey].vkey & 0x1000) flags |= KEYEVENTF_EXTENDEDKEY;
+                X11DRV_send_keyboard_input( keymapnotify_hwnd, vkey, keys[vkey].scan, flags, GetTickCount() );
+            }
+
             update_key_state( keystate, vkey, keys[vkey].pressed );
             changed = TRUE;
         }
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 321b631d6ca..511550a8486 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1796,6 +1796,8 @@ BOOL X11DRV_EnterNotify( HWND hwnd, XEvent *xev )

     TRACE( "hwnd %p/%lx pos %d,%d detail %d\n", hwnd, event->window, event->x, event->y, event->detail );

+    x11drv_thread_data()->keymapnotify_hwnd = hwnd;
+
     if (event->detail == NotifyVirtual) return FALSE;
     if (hwnd == x11drv_thread_data()->grab_hwnd) return FALSE;

diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 52990283ce7..213143014a7 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -369,6 +369,7 @@ struct x11drv_thread_data
     XEvent  *current_event;        /* event currently being processed */
     HWND     grab_hwnd;            /* window that currently grabs the mouse */
     HWND     last_focus;           /* last window that had focus */
+    HWND     keymapnotify_hwnd;    /* window that should receive modifier release events */
     XIM      xim;                  /* input method */
     HWND     last_xic_hwnd;        /* last xic window */
     XFontSet font_set;             /* international text drawing font set */
From 695c72575c72161501a2ac508ba1db649e96d1dd Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Fri, 2 Jul 2021 16:01:28 +0300
Subject: [PATCH] user32: Allow the backends to defer restoring minimized
 windows.

When restoring a minimized window the WM_SYSCOMMAND SC_RESTORE message
should arrive after WM_NCACTIVATE but before WM_ACTIVATE and WM_SETFOCUS.

Some games depend on that ordering and the related window state.

For example Project CARS 3 expects window to be both active and in the
foreground (wrt GetActiveWindow() and GetForegroundWindow()) when
receiving those messages.

Without being active the window doesn't restore properly, see
82c6ec3a32f4 ("winex11.drv: Activate window when restoring from iconic state.")

But if the activate messages arrive before the window is in the
foreground, the game tries to re-acquire DirectInput DISCL_FOREGROUND
devices too early and fails, which results in non-working keyboards and
controllers.

CW-Bug-Id: #19011
---
 dlls/user32/focus.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/user32/focus.c b/dlls/user32/focus.c
index 34cc3880cc9..2e1362eaff5 100644
--- a/dlls/user32/focus.c
+++ b/dlls/user32/focus.c
@@ -164,6 +164,12 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
                       (LPARAM)previous );
         if (GetAncestor( hwnd, GA_PARENT ) == GetDesktopWindow())
             PostMessageW( GetDesktopWindow(), WM_PARENTNOTIFY, WM_NCACTIVATE, (LPARAM)hwnd );
+
+        if (GetPropW( hwnd, L"__WINE_RESTORE_WINDOW" ))
+        {
+            SetPropW( hwnd, L"__WINE_RESTORE_WINDOW", NULL );
+            SendMessageW( hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
+        }
     }

     /* now change focus if necessary */
From ed85dc3dd49a6aae8347dae8a3b4300713fc3f6d Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Fri, 2 Jul 2021 16:01:29 +0300
Subject: [PATCH] winex11.drv: Use __WINE_RESTORE_PROPERTY so Window is
 un-minimized on FocusIn.

On X11 / XWayland the PropertyNotify for WM_STATE change from
IconicState to NormalState arrives before the WM_TAKE_FOCUS
ClientMessage or the FocusIn event.

Converting that state change too early to a WM_SYSCOMMAND SC_RESTORE
message results in it (and the ACTIVATE events because of the previous
HAX) arriving without the window being set to foregrounds first.

This breaks the expectations of Project CARS 3 which tries on window
activation / restoration to re-acquire DirectInput devices with
cooperative level set to DISCL_FOREGROUND, which fails.

Signed-off-by: Arkadiusz Hiler <ahiler@codeweavers.com>

CW-Bug-Id: #19011
---
 dlls/winex11.drv/event.c | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 271a70940f1..3a903eebd7e 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -80,6 +80,8 @@ extern BOOL ximInComposeMode;
 #define XEMBED_UNREGISTER_ACCELERATOR 13
 #define XEMBED_ACTIVATE_ACCELERATOR   14

+static const WCHAR restore_window_propW[] = {'_','_','W','I','N','E','_','R','E','S','T','O','R','E','_','W','I','N','D','O','W',0};
+
 Bool (*pXGetEventData)( Display *display, XEvent /*XGenericEventCookie*/ *event ) = NULL;
 void (*pXFreeEventData)( Display *display, XEvent /*XGenericEventCookie*/ *event ) = NULL;

@@ -586,7 +588,7 @@ static inline BOOL can_activate_window( HWND hwnd )

     if (!(style & WS_VISIBLE)) return FALSE;
     if ((style & (WS_POPUP|WS_CHILD)) == WS_CHILD) return FALSE;
-    if (style & WS_MINIMIZE) return FALSE;
+    if ((style & WS_MINIMIZE) && !GetPropW( hwnd, restore_window_propW )) return FALSE;
     if (GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_NOACTIVATE) return FALSE;
     if (hwnd == GetDesktopWindow()) return FALSE;
     if (GetWindowRect( hwnd, &rect ) && IsRectEmpty( &rect )) return FALSE;
@@ -1371,9 +1373,10 @@ static void handle_wm_state_notify( HWND hwnd, XPropertyEvent *event, BOOL updat
             {
                 TRACE( "restoring win %p/%lx\n", data->hwnd, data->whole_window );
                 release_win_data( data );
-                if ((style & (WS_MINIMIZE | WS_VISIBLE)) == (WS_MINIMIZE | WS_VISIBLE))
-                    SetActiveWindow( hwnd );
-                SendMessageW( hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
+                if ((style & (WS_MINIMIZE | WS_VISIBLE)) == (WS_MINIMIZE | WS_VISIBLE) && GetActiveWindow() != hwnd)
+                    SetPropW( hwnd, restore_window_propW, (HANDLE) TRUE );
+                else
+                    SendMessageW( hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
                 return;
             }
             TRACE( "not restoring win %p/%lx style %08x\n", data->hwnd, data->whole_window, style );
